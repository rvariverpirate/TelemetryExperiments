
out.elf:     file format elf32-tradlittlemips


Disassembly of section .config_BFC02FF0:

bfc02ff0 <__config_BFC02FF0>:
bfc02ff0:	ff ff fe fa                                         ....

Disassembly of section .config_BFC02FF4:

bfc02ff4 <__config_BFC02FF4>:
bfc02ff4:	d9 79 f8 ff                                         .y..

Disassembly of section .config_BFC02FF8:

bfc02ff8 <__config_BFC02FF8>:
bfc02ff8:	db ce 6c ff                                         ..l.

Disassembly of section .config_BFC02FFC:

bfc02ffc <__config_BFC02FFC>:
bfc02ffc:	ff ff ff 7e                                         ...~

Disassembly of section .reset:

bd001970 <_reset>:
bd001970:	0f40065e 	jal	bd001978 <_startup>
bd001974:	00000000 	nop

bd001978 <_startup>:
bd001978:	401a6000 	mfc0	k0,c0_status
bd00197c:	7f5a04c0 	ext	k0,k0,0x13,0x1
bd001980:	13400005 	beqz	k0,bd001998 <_no_nmi>
bd001984:	00000000 	nop
bd001988:	3c1a9d00 	lui	k0,0x9d00
bd00198c:	275a373c 	addiu	k0,k0,14140
bd001990:	03400008 	jr	k0
bd001994:	00000000 	nop

bd001998 <_no_nmi>:
bd001998:	3c1da002 	lui	sp,0xa002
bd00199c:	27bdfff8 	addiu	sp,sp,-8
bd0019a0:	3c1ca000 	lui	gp,0xa000
bd0019a4:	279c7ff0 	addiu	gp,gp,32752
bd0019a8:	40096002 	mfc0	t1,c0_srsctl
bd0019ac:	01205820 	add	t3,t1,zero
bd0019b0:	7d2a1e80 	ext	t2,t1,0x1a,0x4
bd0019b4:	7d494984 	ins	t1,t2,0x6,0x4
bd0019b8:	40896002 	mtc0	t1,c0_srsctl
bd0019bc:	000000c0 	ehb
bd0019c0:	41dce000 	wrpgpr	gp,gp
bd0019c4:	408b6002 	mtc0	t3,c0_srsctl
bd0019c8:	000000c0 	ehb
bd0019cc:	3c089d00 	lui	t0,0x9d00
bd0019d0:	25083764 	addiu	t0,t0,14180
bd0019d4:	0100f809 	jalr	t0
bd0019d8:	00000000 	nop

bd0019dc <_start_bss_init>:
bd0019dc:	3c08a000 	lui	t0,0xa000
bd0019e0:	25080000 	addiu	t0,t0,0
bd0019e4:	3c09a000 	lui	t1,0xa000
bd0019e8:	25290000 	addiu	t1,t1,0
bd0019ec:	10000006 	b	bd001a08 <_bss_check>
bd0019f0:	00000000 	nop

bd0019f4 <_bss_init>:
bd0019f4:	ad000000 	sw	zero,0(t0)
bd0019f8:	ad000004 	sw	zero,4(t0)
bd0019fc:	ad000008 	sw	zero,8(t0)
bd001a00:	ad00000c 	sw	zero,12(t0)
bd001a04:	25080010 	addiu	t0,t0,16

bd001a08 <_bss_check>:
bd001a08:	0109082b 	sltu	at,t0,t1
bd001a0c:	1420fff9 	bnez	at,bd0019f4 <_bss_init>
bd001a10:	00000000 	nop

bd001a14 <_dinit_init>:
bd001a14:	3c089d00 	lui	t0,0x9d00
bd001a18:	25083754 	addiu	t0,t0,14164
bd001a1c:	8d090000 	lw	t1,0(t0)
bd001a20:	11200018 	beqz	t1,bd001a84 <_dinit_end+0x18>
bd001a24:	25080004 	addiu	t0,t0,4
bd001a28:	8d0a0000 	lw	t2,0(t0)
bd001a2c:	25080004 	addiu	t0,t0,4
bd001a30:	8d0b0000 	lw	t3,0(t0)
bd001a34:	11600009 	beqz	t3,bd001a5c <_dinit_clear>
bd001a38:	25080004 	addiu	t0,t0,4

bd001a3c <_dinit_copy>:
bd001a3c:	910c0000 	lbu	t4,0(t0)
bd001a40:	254affff 	addiu	t2,t2,-1
bd001a44:	25080001 	addiu	t0,t0,1
bd001a48:	a12c0000 	sb	t4,0(t1)
bd001a4c:	1540fffb 	bnez	t2,bd001a3c <_dinit_copy>
bd001a50:	25290001 	addiu	t1,t1,1
bd001a54:	10000005 	b	bd001a6c <_dinit_end>
bd001a58:	00000000 	nop

bd001a5c <_dinit_clear>:
bd001a5c:	a1200000 	sb	zero,0(t1)
bd001a60:	254affff 	addiu	t2,t2,-1
bd001a64:	1540fffd 	bnez	t2,bd001a5c <_dinit_clear>
bd001a68:	25290001 	addiu	t1,t1,1

bd001a6c <_dinit_end>:
bd001a6c:	25080003 	addiu	t0,t0,3
bd001a70:	240afffc 	li	t2,-4
bd001a74:	01484024 	and	t0,t2,t0
bd001a78:	8d090000 	lw	t1,0(t0)
bd001a7c:	1520ffe7 	bnez	t1,bd001a1c <_dinit_init+0x8>
bd001a80:	00000000 	nop
bd001a84:	3c090000 	lui	t1,0x0
bd001a88:	25290000 	addiu	t1,t1,0
bd001a8c:	11200010 	beqz	t1,bd001ad0 <_ramfunc_done>
bd001a90:	00000000 	nop
bd001a94:	3c090002 	lui	t1,0x2
bd001a98:	25290000 	addiu	t1,t1,0
bd001a9c:	3c0abf88 	lui	t2,0xbf88
bd001aa0:	254a2010 	addiu	t2,t2,8208
bd001aa4:	ad490000 	sw	t1,0(t2)
bd001aa8:	3c090002 	lui	t1,0x2
bd001aac:	25290000 	addiu	t1,t1,0
bd001ab0:	3c0abf88 	lui	t2,0xbf88
bd001ab4:	254a2020 	addiu	t2,t2,8224
bd001ab8:	ad490000 	sw	t1,0(t2)
bd001abc:	3c090002 	lui	t1,0x2
bd001ac0:	25290000 	addiu	t1,t1,0
bd001ac4:	3c0abf88 	lui	t2,0xbf88
bd001ac8:	254a2030 	addiu	t2,t2,8240
bd001acc:	ad490000 	sw	t1,0(t2)

bd001ad0 <_ramfunc_done>:
bd001ad0:	40804800 	mtc0	zero,c0_count
bd001ad4:	240affff 	li	t2,-1
bd001ad8:	408a5800 	mtc0	t2,c0_compare
bd001adc:	3c080040 	lui	t0,0x40
bd001ae0:	400a6000 	mfc0	t2,c0_status
bd001ae4:	010a5025 	or	t2,t0,t2
bd001ae8:	408a6000 	mtc0	t2,c0_status
bd001aec:	3c099d00 	lui	t1,0x9d00
bd001af0:	25290000 	addiu	t1,t1,0
bd001af4:	000000c0 	ehb
bd001af8:	40897801 	mtc0	t1,c0_ebase
bd001afc:	3c090000 	lui	t1,0x0
bd001b00:	25290001 	addiu	t1,t1,1
bd001b04:	240a0000 	li	t2,0
bd001b08:	7d2a4944 	ins	t2,t1,0x5,0x5
bd001b0c:	408a6001 	mtc0	t2,c0_intctl
bd001b10:	3c090080 	lui	t1,0x80
bd001b14:	40896800 	mtc0	t1,c0_cause
bd001b18:	40088000 	mfc0	t0,c0_config
bd001b1c:	7d090580 	ext	t1,t0,0x16,0x1
bd001b20:	00094c40 	sll	t1,t1,0x11
bd001b24:	40086000 	mfc0	t0,c0_status
bd001b28:	3c010058 	lui	at,0x58
bd001b2c:	01014024 	and	t0,t0,at
bd001b30:	01284025 	or	t0,t1,t0
bd001b34:	40886000 	mtc0	t0,c0_status
bd001b38:	000000c0 	ehb
bd001b3c:	3c089d00 	lui	t0,0x9d00
bd001b40:	2508376c 	addiu	t0,t0,14188
bd001b44:	0100f809 	jalr	t0
bd001b48:	00000000 	nop
bd001b4c:	40086000 	mfc0	t0,c0_status
bd001b50:	3c01ffbf 	lui	at,0xffbf
bd001b54:	3421ffff 	ori	at,at,0xffff
bd001b58:	01014024 	and	t0,t0,at
bd001b5c:	40886000 	mtc0	t0,c0_status
bd001b60:	30840000 	andi	a0,a0,0x0
bd001b64:	30a50000 	andi	a1,a1,0x0
bd001b68:	3c089d00 	lui	t0,0x9d00
bd001b6c:	250835a4 	addiu	t0,t0,13732
bd001b70:	01000008 	jr	t0
bd001b74:	00000000 	nop

Disassembly of section .bev_excpt:

bd001cf0 <_bev_exception>:
bd001cf0:	3c1a9d00 	lui	k0,0x9d00
bd001cf4:	275a35f8 	addiu	k0,k0,13816
bd001cf8:	03400008 	jr	k0
bd001cfc:	00000000 	nop

Disassembly of section .app_excpt:

9d000180 <_gen_exception>:
9d000180:	3c1a9d00 	lui	k0,0x9d00
9d000184:	275a33ac 	addiu	k0,k0,13228
9d000188:	03400008 	jr	k0
9d00018c:	00000000 	nop

Disassembly of section .vector_0:

9d000200 <__vector_dispatch_0>:
9d000200:	0b400da2 	j	9d003688 <.LFE0>
9d000204:	00000000 	nop

Disassembly of section .vector_1:

9d000220 <__vector_dispatch_1>:
9d000220:	0b400da2 	j	9d003688 <.LFE0>
9d000224:	00000000 	nop

Disassembly of section .vector_2:

9d000240 <__vector_dispatch_2>:
9d000240:	0b400da2 	j	9d003688 <.LFE0>
9d000244:	00000000 	nop

Disassembly of section .vector_3:

9d000260 <__vector_dispatch_3>:
9d000260:	0b400da2 	j	9d003688 <.LFE0>
9d000264:	00000000 	nop

Disassembly of section .vector_4:

9d000280 <__vector_dispatch_4>:
9d000280:	0b400da2 	j	9d003688 <.LFE0>
9d000284:	00000000 	nop

Disassembly of section .vector_5:

9d0002a0 <__vector_dispatch_5>:
9d0002a0:	0b400da2 	j	9d003688 <.LFE0>
9d0002a4:	00000000 	nop

Disassembly of section .vector_6:

9d0002c0 <__vector_dispatch_6>:
9d0002c0:	0b400da2 	j	9d003688 <.LFE0>
9d0002c4:	00000000 	nop

Disassembly of section .vector_7:

9d0002e0 <__vector_dispatch_7>:
9d0002e0:	0b400da2 	j	9d003688 <.LFE0>
9d0002e4:	00000000 	nop

Disassembly of section .vector_8:

9d000300 <__vector_dispatch_8>:
9d000300:	0b400da2 	j	9d003688 <.LFE0>
9d000304:	00000000 	nop

Disassembly of section .vector_9:

9d000320 <__vector_dispatch_9>:
9d000320:	0b400da2 	j	9d003688 <.LFE0>
9d000324:	00000000 	nop

Disassembly of section .vector_10:

9d000340 <__vector_dispatch_10>:
9d000340:	0b400da2 	j	9d003688 <.LFE0>
9d000344:	00000000 	nop

Disassembly of section .vector_11:

9d000360 <__vector_dispatch_11>:
9d000360:	0b400da2 	j	9d003688 <.LFE0>
9d000364:	00000000 	nop

Disassembly of section .vector_12:

9d000380 <__vector_dispatch_12>:
9d000380:	0b400da2 	j	9d003688 <.LFE0>
9d000384:	00000000 	nop

Disassembly of section .vector_13:

9d0003a0 <__vector_dispatch_13>:
9d0003a0:	0b400da2 	j	9d003688 <.LFE0>
9d0003a4:	00000000 	nop

Disassembly of section .vector_14:

9d0003c0 <__vector_dispatch_14>:
9d0003c0:	0b400da2 	j	9d003688 <.LFE0>
9d0003c4:	00000000 	nop

Disassembly of section .vector_15:

9d0003e0 <__vector_dispatch_15>:
9d0003e0:	0b400da2 	j	9d003688 <.LFE0>
9d0003e4:	00000000 	nop

Disassembly of section .vector_16:

9d000400 <__vector_dispatch_16>:
9d000400:	0b400da2 	j	9d003688 <.LFE0>
9d000404:	00000000 	nop

Disassembly of section .vector_17:

9d000420 <__vector_dispatch_17>:
9d000420:	0b400da2 	j	9d003688 <.LFE0>
9d000424:	00000000 	nop

Disassembly of section .vector_18:

9d000440 <__vector_dispatch_18>:
9d000440:	0b400da2 	j	9d003688 <.LFE0>
9d000444:	00000000 	nop

Disassembly of section .vector_19:

9d000460 <__vector_dispatch_19>:
9d000460:	0b400da2 	j	9d003688 <.LFE0>
9d000464:	00000000 	nop

Disassembly of section .vector_20:

9d000480 <__vector_dispatch_20>:
9d000480:	0b400da2 	j	9d003688 <.LFE0>
9d000484:	00000000 	nop

Disassembly of section .vector_21:

9d0004a0 <__vector_dispatch_21>:
9d0004a0:	0b400da2 	j	9d003688 <.LFE0>
9d0004a4:	00000000 	nop

Disassembly of section .vector_22:

9d0004c0 <__vector_dispatch_22>:
9d0004c0:	0b400da2 	j	9d003688 <.LFE0>
9d0004c4:	00000000 	nop

Disassembly of section .vector_23:

9d0004e0 <__vector_dispatch_23>:
9d0004e0:	0b400da2 	j	9d003688 <.LFE0>
9d0004e4:	00000000 	nop

Disassembly of section .vector_24:

9d000500 <__vector_dispatch_24>:
9d000500:	0b400da2 	j	9d003688 <.LFE0>
9d000504:	00000000 	nop

Disassembly of section .vector_25:

9d000520 <__vector_dispatch_25>:
9d000520:	0b400da2 	j	9d003688 <.LFE0>
9d000524:	00000000 	nop

Disassembly of section .vector_26:

9d000540 <__vector_dispatch_26>:
9d000540:	0b400da2 	j	9d003688 <.LFE0>
9d000544:	00000000 	nop

Disassembly of section .vector_27:

9d000560 <__vector_dispatch_27>:
9d000560:	0b400da2 	j	9d003688 <.LFE0>
9d000564:	00000000 	nop

Disassembly of section .vector_28:

9d000580 <__vector_dispatch_28>:
9d000580:	0b400da2 	j	9d003688 <.LFE0>
9d000584:	00000000 	nop

Disassembly of section .vector_29:

9d0005a0 <__vector_dispatch_29>:
9d0005a0:	0b400da2 	j	9d003688 <.LFE0>
9d0005a4:	00000000 	nop

Disassembly of section .vector_30:

9d0005c0 <__vector_dispatch_30>:
9d0005c0:	0b400da2 	j	9d003688 <.LFE0>
9d0005c4:	00000000 	nop

Disassembly of section .vector_31:

9d0005e0 <__vector_dispatch_31>:
9d0005e0:	0b400da2 	j	9d003688 <.LFE0>
9d0005e4:	00000000 	nop

Disassembly of section .vector_32:

9d000600 <__vector_dispatch_32>:
9d000600:	0b400da2 	j	9d003688 <.LFE0>
9d000604:	00000000 	nop

Disassembly of section .vector_33:

9d000620 <__vector_dispatch_33>:
9d000620:	0b400da2 	j	9d003688 <.LFE0>
9d000624:	00000000 	nop

Disassembly of section .vector_34:

9d000640 <__vector_dispatch_34>:
9d000640:	0b400da2 	j	9d003688 <.LFE0>
9d000644:	00000000 	nop

Disassembly of section .vector_35:

9d000660 <__vector_dispatch_35>:
9d000660:	0b400da2 	j	9d003688 <.LFE0>
9d000664:	00000000 	nop

Disassembly of section .vector_36:

9d000680 <__vector_dispatch_36>:
9d000680:	0b400da2 	j	9d003688 <.LFE0>
9d000684:	00000000 	nop

Disassembly of section .vector_37:

9d0006a0 <__vector_dispatch_37>:
9d0006a0:	0b400da2 	j	9d003688 <.LFE0>
9d0006a4:	00000000 	nop

Disassembly of section .vector_38:

9d0006c0 <__vector_dispatch_38>:
9d0006c0:	0b400da2 	j	9d003688 <.LFE0>
9d0006c4:	00000000 	nop

Disassembly of section .vector_39:

9d0006e0 <__vector_dispatch_39>:
9d0006e0:	0b400da2 	j	9d003688 <.LFE0>
9d0006e4:	00000000 	nop

Disassembly of section .vector_40:

9d000700 <__vector_dispatch_40>:
9d000700:	0b400da2 	j	9d003688 <.LFE0>
9d000704:	00000000 	nop

Disassembly of section .vector_41:

9d000720 <__vector_dispatch_41>:
9d000720:	0b400da2 	j	9d003688 <.LFE0>
9d000724:	00000000 	nop

Disassembly of section .vector_42:

9d000740 <__vector_dispatch_42>:
9d000740:	0b400da2 	j	9d003688 <.LFE0>
9d000744:	00000000 	nop

Disassembly of section .vector_43:

9d000760 <__vector_dispatch_43>:
9d000760:	0b400da2 	j	9d003688 <.LFE0>
9d000764:	00000000 	nop

Disassembly of section .vector_44:

9d000780 <__vector_dispatch_44>:
9d000780:	0b400da2 	j	9d003688 <.LFE0>
9d000784:	00000000 	nop

Disassembly of section .vector_45:

9d0007a0 <__vector_dispatch_45>:
9d0007a0:	0b400da2 	j	9d003688 <.LFE0>
9d0007a4:	00000000 	nop

Disassembly of section .vector_46:

9d0007c0 <__vector_dispatch_46>:
9d0007c0:	0b400da2 	j	9d003688 <.LFE0>
9d0007c4:	00000000 	nop

Disassembly of section .vector_47:

9d0007e0 <__vector_dispatch_47>:
9d0007e0:	0b400da2 	j	9d003688 <.LFE0>
9d0007e4:	00000000 	nop

Disassembly of section .vector_48:

9d000800 <__vector_dispatch_48>:
9d000800:	0b400da2 	j	9d003688 <.LFE0>
9d000804:	00000000 	nop

Disassembly of section .vector_49:

9d000820 <__vector_dispatch_49>:
9d000820:	0b400da2 	j	9d003688 <.LFE0>
9d000824:	00000000 	nop

Disassembly of section .vector_50:

9d000840 <__vector_dispatch_50>:
9d000840:	0b400da2 	j	9d003688 <.LFE0>
9d000844:	00000000 	nop

Disassembly of section .vector_51:

9d000860 <__vector_dispatch_51>:
9d000860:	0b400da2 	j	9d003688 <.LFE0>
9d000864:	00000000 	nop

Disassembly of section ._debug_exception:

bfc00480 <__DbgExecReturn>:
bfc00480:	409bf800 	mtc0	k1,c0_desave
bfc00484:	000000c0 	ehb
bfc00488:	3c1b9d00 	lui	k1,0x9d00
bfc0048c:	277b36d0 	addiu	k1,k1,14032
bfc00490:	13600002 	beqz	k1,bfc0049c <__DbgExecReturn+0x1c>
bfc00494:	00000000 	nop
bfc00498:	409bc000 	mtc0	k1,c0_depc
bfc0049c:	401bf800 	mfc0	k1,c0_desave
bfc004a0:	000000c0 	ehb
bfc004a4:	4200001f 	deret
bfc004a8:	00000000 	nop

Disassembly of section .text:

9d001e00 <nrf24l01_clear_ce>:
}

//clears the pin on the host microcontroller that is attached to the 24l01's CE pin
void nrf24l01_clear_ce()
{
	nrf24l01_CE_IOREGISTER &= ~nrf24l01_CE_PINMASK;
9d001e00:	3c02bf88 	lui	v0,0xbf88
9d001e04:	8c436050 	lw	v1,24656(v0)
9d001e08:	7c033184 	ins	v1,zero,0x6,0x1
9d001e0c:	ac436050 	sw	v1,24656(v0)
9d001e10:	03e00008 	jr	ra
9d001e14:	00000000 	nop

9d001e18 <nrf24l01_rx_active_to_standby>:
	nrf24l01_set_ce();
}

//takes a 24L01 that is already in active RX mode and puts it in RX standy mode
void nrf24l01_rx_active_to_standby()
{
9d001e18:	27bdffe8 	addiu	sp,sp,-24
9d001e1c:	afbf0014 	sw	ra,20(sp)
	nrf24l01_clear_ce();
9d001e20:	0f400780 	jal	9d001e00 <nrf24l01_clear_ce>
9d001e24:	00000000 	nop
}
9d001e28:	8fbf0014 	lw	ra,20(sp)
9d001e2c:	03e00008 	jr	ra
9d001e30:	27bd0018 	addiu	sp,sp,24

9d001e34 <nrf24l01_set_ce>:
}

//sets the pin on the host microcontroller that is attached to the 24l01's CE pin
void nrf24l01_set_ce()
{
	nrf24l01_CE_IOREGISTER |= nrf24l01_CE_PINMASK;
9d001e34:	3c02bf88 	lui	v0,0xbf88
9d001e38:	8c436050 	lw	v1,24656(v0)
9d001e3c:	34630040 	ori	v1,v1,0x40
9d001e40:	ac436050 	sw	v1,24656(v0)
9d001e44:	03e00008 	jr	ra
9d001e48:	00000000 	nop

9d001e4c <nrf24l01_rx_standby_to_active>:
		nrf24l01_power_down_param(config);
}

//takes a 24L01 that is already in RX standby mode and puts it in active RX mode
void nrf24l01_rx_standby_to_active()
{
9d001e4c:	27bdffe8 	addiu	sp,sp,-24
9d001e50:	afbf0014 	sw	ra,20(sp)
	nrf24l01_set_ce();
9d001e54:	0f40078d 	jal	9d001e34 <nrf24l01_set_ce>
9d001e58:	00000000 	nop
}
9d001e5c:	8fbf0014 	lw	ra,20(sp)
9d001e60:	03e00008 	jr	ra
9d001e64:	27bd0018 	addiu	sp,sp,24

9d001e68 <nrf24l01_transmit>:
	return nrf24l01_execute_command(nrf24l01_NOP, NULL, 0, true);
}

//transmits the current tx payload
void nrf24l01_transmit()
{
9d001e68:	27bdffe8 	addiu	sp,sp,-24
9d001e6c:	afbf0014 	sw	ra,20(sp)
	nrf24l01_set_ce();
9d001e70:	0f40078d 	jal	9d001e34 <nrf24l01_set_ce>
9d001e74:	00000000 	nop
	delay_us(10);
9d001e78:	0f400d51 	jal	9d003544 <DelayUS>
9d001e7c:	2404000a 	li	a0,10
	nrf24l01_clear_ce();
9d001e80:	0f400780 	jal	9d001e00 <nrf24l01_clear_ce>
9d001e84:	00000000 	nop
}
9d001e88:	8fbf0014 	lw	ra,20(sp)
9d001e8c:	03e00008 	jr	ra
9d001e90:	27bd0018 	addiu	sp,sp,24

9d001e94 <nrf24l01_ce_pin_active>:
}

//returns true if CE is high, false if not
bool nrf24l01_ce_pin_active()
{
	if((nrf24l01_CE_IOREGISTER & nrf24l01_CE_PINMASK) != 0)
9d001e94:	3c02bf88 	lui	v0,0xbf88
9d001e98:	8c426050 	lw	v0,24656(v0)
		return true;
	else
		return false;
}
9d001e9c:	03e00008 	jr	ra
9d001ea0:	7c420180 	ext	v0,v0,0x6,0x1

9d001ea4 <nrf24l01_clear_csn>:

//sets the pin on the host microcontroller that is attached to the 24l01's CSN pin
void nrf24l01_clear_csn()
{
	nrf24l01_CSN_IOREGISTER &= ~nrf24l01_CSN_PINMASK;
9d001ea4:	3c02bf88 	lui	v0,0xbf88
9d001ea8:	8c436050 	lw	v1,24656(v0)
9d001eac:	7c0339c4 	ins	v1,zero,0x7,0x1
9d001eb0:	ac436050 	sw	v1,24656(v0)
9d001eb4:	03e00008 	jr	ra
9d001eb8:	00000000 	nop

9d001ebc <nrf24l01_set_csn>:
}

//clears the pin on the host microcontroller that is attached to the 24l01's CSN pin
void nrf24l01_set_csn()
{
	nrf24l01_CSN_IOREGISTER |= nrf24l01_CSN_PINMASK;
9d001ebc:	3c02bf88 	lui	v0,0xbf88
9d001ec0:	8c436050 	lw	v1,24656(v0)
9d001ec4:	34630080 	ori	v1,v1,0x80
9d001ec8:	ac436050 	sw	v1,24656(v0)
9d001ecc:	03e00008 	jr	ra
9d001ed0:	00000000 	nop

9d001ed4 <nrf24l01_csn_pin_active>:
}

//returns true if CSN is high, false if not
bool nrf24l01_csn_pin_active()
{
	if((nrf24l01_CSN_IOREGISTER & nrf24l01_CSN_PINMASK) != 0)
9d001ed4:	3c02bf88 	lui	v0,0xbf88
9d001ed8:	8c426050 	lw	v0,24656(v0)
		return true;
	else
		return false;	
}
9d001edc:	03e00008 	jr	ra
9d001ee0:	7c4201c0 	ext	v0,v0,0x7,0x1

9d001ee4 <nrf24l01_irq_pin_active>:
}

//returns true if IRQ pin is low, false otherwise
bool nrf24l01_irq_pin_active()
{
	if((nrf24l01_IRQ_IOREGISTER & nrf24l01_IRQ_PINMASK) != 0)
9d001ee4:	3c02bf88 	lui	v0,0xbf88
9d001ee8:	8c426050 	lw	v0,24656(v0)
9d001eec:	38420001 	xori	v0,v0,0x1
		return false;
	else
		return true;
}
9d001ef0:	03e00008 	jr	ra
9d001ef4:	30420001 	andi	v0,v0,0x1

9d001ef8 <nrf24l01_get_rx_pipe_from_status>:
}

unsigned char nrf24l01_get_rx_pipe_from_status(unsigned char status)
{
	return ((status & 0xE) >> 1);
}
9d001ef8:	03e00008 	jr	ra
9d001efc:	7c821040 	ext	v0,a0,0x1,0x3

9d001f00 <nrf24l01_spi_send_read>:
void nrf24l01_spi_send_read(unsigned char * data, unsigned int len, bool copydata)
{
	unsigned int count;
	unsigned char tempbyte;

	for(count = 0; count < len; count++)
9d001f00:	10a00018 	beqz	a1,9d001f64 <nrf24l01_spi_send_read+0x64>
9d001f04:	00000000 	nop
}

//low-level spi send function for library use
//the user should not call this function directly, but rather use one of the 8 SPI data instructions
void nrf24l01_spi_send_read(unsigned char * data, unsigned int len, bool copydata)
{
9d001f08:	27bdffe0 	addiu	sp,sp,-32
9d001f0c:	afbf001c 	sw	ra,28(sp)
9d001f10:	afb20018 	sw	s2,24(sp)
9d001f14:	afb10014 	sw	s1,20(sp)
9d001f18:	afb00010 	sw	s0,16(sp)
9d001f1c:	00c08821 	move	s1,a2
9d001f20:	00808021 	move	s0,a0
9d001f24:	00859021 	addu	s2,a0,a1
	unsigned int count;
	unsigned char tempbyte;

	for(count = 0; count < len; count++)
	{
		if(copydata != false)
9d001f28:	12200005 	beqz	s1,9d001f40 <nrf24l01_spi_send_read+0x40>
9d001f2c:	00000000 	nop
			data[count] = spi4_send_read_byte(data[count]);
9d001f30:	0f400d47 	jal	9d00351c <spi4_send_read_byte>
9d001f34:	92040000 	lbu	a0,0(s0)
9d001f38:	0b4007d2 	j	9d001f48 <nrf24l01_spi_send_read+0x48>
9d001f3c:	a2020000 	sb	v0,0(s0)
		else
		{
			tempbyte = data[count];
			spi4_send_read_byte(tempbyte);
9d001f40:	0f400d47 	jal	9d00351c <spi4_send_read_byte>
9d001f44:	92040000 	lbu	a0,0(s0)
9d001f48:	26100001 	addiu	s0,s0,1
void nrf24l01_spi_send_read(unsigned char * data, unsigned int len, bool copydata)
{
	unsigned int count;
	unsigned char tempbyte;

	for(count = 0; count < len; count++)
9d001f4c:	1612fff6 	bne	s0,s2,9d001f28 <nrf24l01_spi_send_read+0x28>
9d001f50:	8fbf001c 	lw	ra,28(sp)
		{
			tempbyte = data[count];
			spi4_send_read_byte(tempbyte);
		}
	}
}
9d001f54:	8fb20018 	lw	s2,24(sp)
9d001f58:	8fb10014 	lw	s1,20(sp)
9d001f5c:	8fb00010 	lw	s0,16(sp)
9d001f60:	27bd0020 	addiu	sp,sp,32
9d001f64:	03e00008 	jr	ra
9d001f68:	00000000 	nop

9d001f6c <nrf24l01_execute_command>:
}

//low-level spi send function for library use
//the user should not call this function directly, but rather use one of the 8 SPI data instructions
unsigned char nrf24l01_execute_command(unsigned char instruction, unsigned char * data, unsigned int len, bool copydata)
{
9d001f6c:	27bdffd0 	addiu	sp,sp,-48
9d001f70:	afbf002c 	sw	ra,44(sp)
9d001f74:	afb30028 	sw	s3,40(sp)
9d001f78:	afb20024 	sw	s2,36(sp)
9d001f7c:	afb10020 	sw	s1,32(sp)
9d001f80:	afb0001c 	sw	s0,28(sp)
9d001f84:	00809821 	move	s3,a0
9d001f88:	00a09021 	move	s2,a1
9d001f8c:	00c08821 	move	s1,a2
	unsigned char status;
	
	nrf24l01_clear_csn();
9d001f90:	0f4007a9 	jal	9d001ea4 <nrf24l01_clear_csn>
9d001f94:	00e08021 	move	s0,a3

	status = instruction;
9d001f98:	a3b30010 	sb	s3,16(sp)
	nrf24l01_spi_send_read(&status, 1, true);
9d001f9c:	27a40010 	addiu	a0,sp,16
9d001fa0:	24050001 	li	a1,1
9d001fa4:	0f4007c0 	jal	9d001f00 <nrf24l01_spi_send_read>
9d001fa8:	24060001 	li	a2,1
	nrf24l01_spi_send_read(data, len, copydata);
9d001fac:	02402021 	move	a0,s2
9d001fb0:	02202821 	move	a1,s1
9d001fb4:	0f4007c0 	jal	9d001f00 <nrf24l01_spi_send_read>
9d001fb8:	02003021 	move	a2,s0
	
	nrf24l01_set_csn();		
9d001fbc:	0f4007af 	jal	9d001ebc <nrf24l01_set_csn>
9d001fc0:	00000000 	nop

	return status;
}
9d001fc4:	93a20010 	lbu	v0,16(sp)
9d001fc8:	8fbf002c 	lw	ra,44(sp)
9d001fcc:	8fb30028 	lw	s3,40(sp)
9d001fd0:	8fb20024 	lw	s2,36(sp)
9d001fd4:	8fb10020 	lw	s1,32(sp)
9d001fd8:	8fb0001c 	lw	s0,28(sp)
9d001fdc:	03e00008 	jr	ra
9d001fe0:	27bd0030 	addiu	sp,sp,48

9d001fe4 <nrf24l01_write_register>:
//  length for the register the address is being sent to.
//unsigned int len is always the size of unsigned char * data.  For example, if data is declared as
//  data[6], len should equal 6.
//returns the value of the STATUS register
unsigned char nrf24l01_write_register(unsigned char regnumber, unsigned char * data, unsigned int len)
{
9d001fe4:	27bdffe8 	addiu	sp,sp,-24
9d001fe8:	afbf0014 	sw	ra,20(sp)
	return nrf24l01_execute_command(nrf24l01_W_REGISTER | (regnumber & nrf24l01_W_REGISTER_DATA), data, len, false);
9d001fec:	3084001f 	andi	a0,a0,0x1f
9d001ff0:	34840020 	ori	a0,a0,0x20
9d001ff4:	0f4007db 	jal	9d001f6c <nrf24l01_execute_command>
9d001ff8:	00003821 	move	a3,zero
}
9d001ffc:	8fbf0014 	lw	ra,20(sp)
9d002000:	03e00008 	jr	ra
9d002004:	27bd0018 	addiu	sp,sp,24

9d002008 <nrf24l01_power_up_param>:
//  24L01 as a receiver.  If the argument is false, the receiver will remain in
//  standby mode and not monitor for packets.  If the argument is true, the CE
//  pin will be set and the 24L01 will monitor for packets.  In TX mode, the value
//  of this argument is insignificant.
void nrf24l01_power_up_param(bool rx_active_mode, unsigned char config)
{
9d002008:	27bdffe8 	addiu	sp,sp,-24
9d00200c:	afbf0014 	sw	ra,20(sp)
9d002010:	afb00010 	sw	s0,16(sp)
9d002014:	00808021 	move	s0,a0
	unsigned char test, test2;
	
	config |= nrf24l01_CONFIG_PWR_UP;
9d002018:	34a50002 	ori	a1,a1,0x2
9d00201c:	a3a5001c 	sb	a1,28(sp)
	
	nrf24l01_write_register(nrf24l01_CONFIG, &config, 1);
9d002020:	00002021 	move	a0,zero
9d002024:	27a5001c 	addiu	a1,sp,28
9d002028:	0f4007f9 	jal	9d001fe4 <nrf24l01_write_register>
9d00202c:	24060001 	li	a2,1

	delay_us(1500);
9d002030:	0f400d51 	jal	9d003544 <DelayUS>
9d002034:	240405dc 	li	a0,1500

	if((config & nrf24l01_CONFIG_PRIM_RX) == 0)
9d002038:	93a2001c 	lbu	v0,28(sp)
9d00203c:	30420001 	andi	v0,v0,0x1
9d002040:	14400005 	bnez	v0,9d002058 <nrf24l01_power_up_param+0x50>
9d002044:	00000000 	nop
		nrf24l01_clear_ce();
9d002048:	0f400780 	jal	9d001e00 <nrf24l01_clear_ce>
9d00204c:	00000000 	nop
9d002050:	0b40081f 	j	9d00207c <nrf24l01_power_up_param+0x74>
9d002054:	8fbf0014 	lw	ra,20(sp)
	else
	{
		if(rx_active_mode != false)
9d002058:	12000005 	beqz	s0,9d002070 <nrf24l01_power_up_param+0x68>
9d00205c:	00000000 	nop
			nrf24l01_set_ce();
9d002060:	0f40078d 	jal	9d001e34 <nrf24l01_set_ce>
9d002064:	00000000 	nop
9d002068:	0b40081f 	j	9d00207c <nrf24l01_power_up_param+0x74>
9d00206c:	8fbf0014 	lw	ra,20(sp)
		else
			nrf24l01_clear_ce();
9d002070:	0f400780 	jal	9d001e00 <nrf24l01_clear_ce>
9d002074:	00000000 	nop
	}
}
9d002078:	8fbf0014 	lw	ra,20(sp)
9d00207c:	8fb00010 	lw	s0,16(sp)
9d002080:	03e00008 	jr	ra
9d002084:	27bd0018 	addiu	sp,sp,24

9d002088 <nrf24l01_initialize_debug_lite>:
//  in all registers to work.  It is recommended that the device be reset or
//  have its power cycled immediately before this code is run.
//in normal circumstances, the user should use nrf24l01_initialize() rather than this
//  function, since this function does not set all of the register values.
void nrf24l01_initialize_debug_lite(bool rx, unsigned char p0_payload_width)
{
9d002088:	27bdffe8 	addiu	sp,sp,-24
9d00208c:	afbf0014 	sw	ra,20(sp)
9d002090:	afb00010 	sw	s0,16(sp)
9d002094:	a3a5001c 	sb	a1,28(sp)
	unsigned char config;
	
	config = nrf24l01_CONFIG_DEFAULT_VAL;
9d002098:	24020008 	li	v0,8
9d00209c:	24100009 	li	s0,9
9d0020a0:	0044800a 	movz	s0,v0,a0
	
	if(rx != false)
		config |= nrf24l01_CONFIG_PRIM_RX;
		
	nrf24l01_write_register(nrf24l01_RX_PW_P0, &p0_payload_width, 1);
9d0020a4:	24040011 	li	a0,17
9d0020a8:	27a5001c 	addiu	a1,sp,28
9d0020ac:	0f4007f9 	jal	9d001fe4 <nrf24l01_write_register>
9d0020b0:	24060001 	li	a2,1
	nrf24l01_power_up_param(true, config);
9d0020b4:	24040001 	li	a0,1
9d0020b8:	0f400802 	jal	9d002008 <nrf24l01_power_up_param>
9d0020bc:	02002821 	move	a1,s0
}
9d0020c0:	8fbf0014 	lw	ra,20(sp)
9d0020c4:	8fb00010 	lw	s0,16(sp)
9d0020c8:	03e00008 	jr	ra
9d0020cc:	27bd0018 	addiu	sp,sp,24

9d0020d0 <nrf24l01_power_down_param>:

//powers down the 24L01
//this function allows the user to set the contents of the CONFIG register, but the function
//  clears the PWR_UP bit in the CONFIG register, so the user does not need to.
void nrf24l01_power_down_param(unsigned char config)
{
9d0020d0:	27bdffe8 	addiu	sp,sp,-24
9d0020d4:	afbf0014 	sw	ra,20(sp)
	config &= (~nrf24l01_CONFIG_PWR_UP);
9d0020d8:	308400fd 	andi	a0,a0,0xfd
9d0020dc:	a3a40018 	sb	a0,24(sp)
	
	nrf24l01_write_register(nrf24l01_CONFIG, &config, 1);
9d0020e0:	00002021 	move	a0,zero
9d0020e4:	27a50018 	addiu	a1,sp,24
9d0020e8:	0f4007f9 	jal	9d001fe4 <nrf24l01_write_register>
9d0020ec:	24060001 	li	a2,1

	nrf24l01_clear_ce();
9d0020f0:	0f400780 	jal	9d001e00 <nrf24l01_clear_ce>
9d0020f4:	00000000 	nop
}
9d0020f8:	8fbf0014 	lw	ra,20(sp)
9d0020fc:	03e00008 	jr	ra
9d002100:	27bd0018 	addiu	sp,sp,24

9d002104 <nrf24l01_set_as_rx_param>:
//  sets the PRIM_RX bit in the CONFIG register, so the user does not need to.
//if the argument rx_active_mode is false, the receiver will remain in standby mode
//  and not monitor for packets.  If the argument is true, the CE pin will be set 
//  and the 24L01 will monitor for packets.
void nrf24l01_set_as_rx_param(bool rx_active_mode, unsigned char config)
{
9d002104:	27bdffe8 	addiu	sp,sp,-24
	config |= nrf24l01_CONFIG_PRIM_RX;
9d002108:	34a20001 	ori	v0,a1,0x1
	
	if((config & nrf24l01_CONFIG_PWR_UP) != 0)
9d00210c:	30a50002 	andi	a1,a1,0x2
9d002110:	30a500ff 	andi	a1,a1,0xff
9d002114:	10a00005 	beqz	a1,9d00212c <nrf24l01_set_as_rx_param+0x28>
9d002118:	afbf0014 	sw	ra,20(sp)
		nrf24l01_power_up_param(rx_active_mode, config);
9d00211c:	0f400802 	jal	9d002008 <nrf24l01_power_up_param>
9d002120:	00402821 	move	a1,v0
9d002124:	0b40084e 	j	9d002138 <nrf24l01_set_as_rx_param+0x34>
9d002128:	8fbf0014 	lw	ra,20(sp)
	else
		nrf24l01_power_down_param(config);
9d00212c:	0f400834 	jal	9d0020d0 <nrf24l01_power_down_param>
9d002130:	00402021 	move	a0,v0
}
9d002134:	8fbf0014 	lw	ra,20(sp)
9d002138:	03e00008 	jr	ra
9d00213c:	27bd0018 	addiu	sp,sp,24

9d002140 <nrf24l01_set_as_tx_param>:

//sets up the 24L01 as a transmitter
//this function allows the user to set the contents of the CONFIG register, but the function
//  clears the PRIM_RX bit in the CONFIG register, so the user does not need to.
void nrf24l01_set_as_tx_param(unsigned char config)
{
9d002140:	27bdffe8 	addiu	sp,sp,-24
	config &= ~(nrf24l01_CONFIG_PRIM_RX);
9d002144:	308500fe 	andi	a1,a0,0xfe
	
	if((config & nrf24l01_CONFIG_PWR_UP) != 0)
9d002148:	30840002 	andi	a0,a0,0x2
9d00214c:	308400ff 	andi	a0,a0,0xff
9d002150:	10800005 	beqz	a0,9d002168 <nrf24l01_set_as_tx_param+0x28>
9d002154:	afbf0014 	sw	ra,20(sp)
		nrf24l01_power_up_param(false, config);
9d002158:	0f400802 	jal	9d002008 <nrf24l01_power_up_param>
9d00215c:	00002021 	move	a0,zero
9d002160:	0b40085d 	j	9d002174 <nrf24l01_set_as_tx_param+0x34>
9d002164:	8fbf0014 	lw	ra,20(sp)
	else
		nrf24l01_power_down_param(config);
9d002168:	0f400834 	jal	9d0020d0 <nrf24l01_power_down_param>
9d00216c:	00a02021 	move	a0,a1
}
9d002170:	8fbf0014 	lw	ra,20(sp)
9d002174:	03e00008 	jr	ra
9d002178:	27bd0018 	addiu	sp,sp,24

9d00217c <nrf24l01_set_tx_addr>:
//unsigned char * address is the actual address to be used.  It should be sized
//	according to the tx_addr length specified to the nrf24l01.
//unsigned int len is the length of the address.  Its value should be specified
//	according to the tx_addr length specified to the nrf24l01.
void nrf24l01_set_tx_addr(unsigned char * address, unsigned int len)
{		
9d00217c:	27bdffe8 	addiu	sp,sp,-24
9d002180:	afbf0014 	sw	ra,20(sp)
9d002184:	00801021 	move	v0,a0
9d002188:	00a03021 	move	a2,a1
	nrf24l01_write_register(nrf24l01_TX_ADDR, address, len);
9d00218c:	24040010 	li	a0,16
9d002190:	0f4007f9 	jal	9d001fe4 <nrf24l01_write_register>
9d002194:	00402821 	move	a1,v0
}
9d002198:	8fbf0014 	lw	ra,20(sp)
9d00219c:	03e00008 	jr	ra
9d0021a0:	27bd0018 	addiu	sp,sp,24

9d0021a4 <nrf24l01_set_rx_addr>:
//unsigned char rxpipenum is the pipe number (zero to five) whose address is being
//	specified.  If an invalid address (greater than five) is supplied, the function
//  does nothing.
void nrf24l01_set_rx_addr(unsigned char * address, unsigned int len, unsigned char rxpipenum)
{	
	if(rxpipenum > 5)
9d0021a4:	2cc20006 	sltiu	v0,a2,6
9d0021a8:	1040000b 	beqz	v0,9d0021d8 <nrf24l01_set_rx_addr+0x34>
9d0021ac:	00803821 	move	a3,a0
//	according to the rx_addr length specified to the nrf24l01.
//unsigned char rxpipenum is the pipe number (zero to five) whose address is being
//	specified.  If an invalid address (greater than five) is supplied, the function
//  does nothing.
void nrf24l01_set_rx_addr(unsigned char * address, unsigned int len, unsigned char rxpipenum)
{	
9d0021b0:	27bdffe8 	addiu	sp,sp,-24
9d0021b4:	afbf0014 	sw	ra,20(sp)
9d0021b8:	00a01821 	move	v1,a1
	if(rxpipenum > 5)
		return;
		
	nrf24l01_write_register(nrf24l01_RX_ADDR_P0 + rxpipenum, address, len);
9d0021bc:	24c4000a 	addiu	a0,a2,10
9d0021c0:	308400ff 	andi	a0,a0,0xff
9d0021c4:	00e02821 	move	a1,a3
9d0021c8:	0f4007f9 	jal	9d001fe4 <nrf24l01_write_register>
9d0021cc:	00603021 	move	a2,v1
}
9d0021d0:	8fbf0014 	lw	ra,20(sp)
9d0021d4:	27bd0018 	addiu	sp,sp,24
9d0021d8:	03e00008 	jr	ra
9d0021dc:	00000000 	nop

9d0021e0 <nrf24l01_set_rx_pw>:
//  specified, the function does nothing.
//unsigned char rxpipenum is the pipe number (zero to five) whose address is being
//	specified.  If an invalid address (greater than five) is supplied, the function
//  does nothing.
void nrf24l01_set_rx_pw(unsigned char payloadwidth, unsigned char rxpipenum)
{
9d0021e0:	27bdffe8 	addiu	sp,sp,-24
9d0021e4:	afbf0014 	sw	ra,20(sp)
	if((rxpipenum > 5) || (payloadwidth > 32))
9d0021e8:	2ca20006 	sltiu	v0,a1,6
9d0021ec:	1040000a 	beqz	v0,9d002218 <nrf24l01_set_rx_pw+0x38>
9d0021f0:	a3a40018 	sb	a0,24(sp)
9d0021f4:	308200ff 	andi	v0,a0,0xff
9d0021f8:	2c420021 	sltiu	v0,v0,33
9d0021fc:	10400007 	beqz	v0,9d00221c <nrf24l01_set_rx_pw+0x3c>
9d002200:	8fbf0014 	lw	ra,20(sp)
		return;
		
	nrf24l01_write_register(nrf24l01_RX_PW_P0 + rxpipenum, &payloadwidth, 1);
9d002204:	24a40011 	addiu	a0,a1,17
9d002208:	308400ff 	andi	a0,a0,0xff
9d00220c:	27a50018 	addiu	a1,sp,24
9d002210:	0f4007f9 	jal	9d001fe4 <nrf24l01_write_register>
9d002214:	24060001 	li	a2,1
}
9d002218:	8fbf0014 	lw	ra,20(sp)
9d00221c:	03e00008 	jr	ra
9d002220:	27bd0018 	addiu	sp,sp,24

9d002224 <nrf24l01_set_config>:
	return data;
}

//sets the value of the CONFIG register
void nrf24l01_set_config(unsigned char config)
{
9d002224:	27bdffe8 	addiu	sp,sp,-24
9d002228:	afbf0014 	sw	ra,20(sp)
9d00222c:	a3a40018 	sb	a0,24(sp)
	nrf24l01_write_register(nrf24l01_CONFIG, &config, 1);
9d002230:	00002021 	move	a0,zero
9d002234:	27a50018 	addiu	a1,sp,24
9d002238:	0f4007f9 	jal	9d001fe4 <nrf24l01_write_register>
9d00223c:	24060001 	li	a2,1
}
9d002240:	8fbf0014 	lw	ra,20(sp)
9d002244:	03e00008 	jr	ra
9d002248:	27bd0018 	addiu	sp,sp,24

9d00224c <nrf24l01_set_rf_ch>:
	return data;
}

//unsigned char channel is the channel to be changed to.
void nrf24l01_set_rf_ch(unsigned char channel)
{
9d00224c:	27bdffe0 	addiu	sp,sp,-32
9d002250:	afbf001c 	sw	ra,28(sp)
	unsigned char data;
	
	data = channel & ~nrf24l01_RF_CH_RESERVED;
9d002254:	3084007f 	andi	a0,a0,0x7f
9d002258:	a3a40010 	sb	a0,16(sp)
	
	nrf24l01_write_register(nrf24l01_RF_CH, &data, 1);
9d00225c:	24040005 	li	a0,5
9d002260:	27a50010 	addiu	a1,sp,16
9d002264:	0f4007f9 	jal	9d001fe4 <nrf24l01_write_register>
9d002268:	24060001 	li	a2,1
}
9d00226c:	8fbf001c 	lw	ra,28(sp)
9d002270:	03e00008 	jr	ra
9d002274:	27bd0020 	addiu	sp,sp,32

9d002278 <nrf24l01_clear_plos_cnt_param>:

//clears the PLOS_CNT field of the OBSERVE_TX register
//this function allows the user to set the RF_CH register by using
//  the argument in the function during the PLOS_CNT clearing process
void nrf24l01_clear_plos_cnt_param(unsigned char rf_ch)
{
9d002278:	27bdffe8 	addiu	sp,sp,-24
9d00227c:	afbf0014 	sw	ra,20(sp)
9d002280:	a3a40018 	sb	a0,24(sp)
	nrf24l01_write_register(nrf24l01_RF_CH, &rf_ch, 1);
9d002284:	24040005 	li	a0,5
9d002288:	27a50018 	addiu	a1,sp,24
9d00228c:	0f4007f9 	jal	9d001fe4 <nrf24l01_write_register>
9d002290:	24060001 	li	a2,1
}
9d002294:	8fbf0014 	lw	ra,20(sp)
9d002298:	03e00008 	jr	ra
9d00229c:	27bd0018 	addiu	sp,sp,24

9d0022a0 <nrf24l01_irq_clear_all>:
	return (nrf24l01_get_status() & nrf24l01_STATUS_MAX_RT);
}

//clear all interrupts in the status register
void nrf24l01_irq_clear_all()
{
9d0022a0:	27bdffe0 	addiu	sp,sp,-32
9d0022a4:	afbf001c 	sw	ra,28(sp)
	unsigned char data = nrf24l01_STATUS_RX_DR | nrf24l01_STATUS_TX_DS | nrf24l01_STATUS_MAX_RT;
9d0022a8:	24020070 	li	v0,112
9d0022ac:	a3a20010 	sb	v0,16(sp)
	
	nrf24l01_write_register(nrf24l01_STATUS, &data, 1); 
9d0022b0:	24040007 	li	a0,7
9d0022b4:	27a50010 	addiu	a1,sp,16
9d0022b8:	0f4007f9 	jal	9d001fe4 <nrf24l01_write_register>
9d0022bc:	24060001 	li	a2,1
}
9d0022c0:	8fbf001c 	lw	ra,28(sp)
9d0022c4:	03e00008 	jr	ra
9d0022c8:	27bd0020 	addiu	sp,sp,32

9d0022cc <nrf24l01_irq_clear_rx_dr>:

//clears only the RX_DR interrupt
void nrf24l01_irq_clear_rx_dr()
{
9d0022cc:	27bdffe0 	addiu	sp,sp,-32
9d0022d0:	afbf001c 	sw	ra,28(sp)
	unsigned char data = nrf24l01_STATUS_RX_DR;
9d0022d4:	24020040 	li	v0,64
9d0022d8:	a3a20010 	sb	v0,16(sp)
	
	nrf24l01_write_register(nrf24l01_STATUS, &data, 1); 
9d0022dc:	24040007 	li	a0,7
9d0022e0:	27a50010 	addiu	a1,sp,16
9d0022e4:	0f4007f9 	jal	9d001fe4 <nrf24l01_write_register>
9d0022e8:	24060001 	li	a2,1
}
9d0022ec:	8fbf001c 	lw	ra,28(sp)
9d0022f0:	03e00008 	jr	ra
9d0022f4:	27bd0020 	addiu	sp,sp,32

9d0022f8 <nrf24l01_irq_clear_tx_ds>:

//clears only the TX_DS interrupt
void nrf24l01_irq_clear_tx_ds()
{
9d0022f8:	27bdffe0 	addiu	sp,sp,-32
9d0022fc:	afbf001c 	sw	ra,28(sp)
	unsigned char data = nrf24l01_STATUS_TX_DS;
9d002300:	24020020 	li	v0,32
9d002304:	a3a20010 	sb	v0,16(sp)
	
	nrf24l01_write_register(nrf24l01_STATUS, &data, 1); 
9d002308:	24040007 	li	a0,7
9d00230c:	27a50010 	addiu	a1,sp,16
9d002310:	0f4007f9 	jal	9d001fe4 <nrf24l01_write_register>
9d002314:	24060001 	li	a2,1
}
9d002318:	8fbf001c 	lw	ra,28(sp)
9d00231c:	03e00008 	jr	ra
9d002320:	27bd0020 	addiu	sp,sp,32

9d002324 <nrf24l01_irq_clear_max_rt>:

//clears only the MAX_RT interrupt
void nrf24l01_irq_clear_max_rt()
{
9d002324:	27bdffe0 	addiu	sp,sp,-32
9d002328:	afbf001c 	sw	ra,28(sp)
	unsigned char data = nrf24l01_STATUS_MAX_RT;
9d00232c:	24020010 	li	v0,16
9d002330:	a3a20010 	sb	v0,16(sp)
	
	nrf24l01_write_register(nrf24l01_STATUS, &data, 1); 
9d002334:	24040007 	li	a0,7
9d002338:	27a50010 	addiu	a1,sp,16
9d00233c:	0f4007f9 	jal	9d001fe4 <nrf24l01_write_register>
9d002340:	24060001 	li	a2,1
}
9d002344:	8fbf001c 	lw	ra,28(sp)
9d002348:	03e00008 	jr	ra
9d00234c:	27bd0020 	addiu	sp,sp,32

9d002350 <nrf24l01_initialize>:
						 unsigned char rx_pw_p1, 
						 unsigned char rx_pw_p2, 
						 unsigned char rx_pw_p3, 
						 unsigned char rx_pw_p4, 
						 unsigned char rx_pw_p5)
{
9d002350:	27bdffc8 	addiu	sp,sp,-56
9d002354:	afbf0034 	sw	ra,52(sp)
9d002358:	afb50030 	sw	s5,48(sp)
9d00235c:	afb4002c 	sw	s4,44(sp)
9d002360:	afb30028 	sw	s3,40(sp)
9d002364:	afb20024 	sw	s2,36(sp)
9d002368:	afb10020 	sw	s1,32(sp)
9d00236c:	afb0001c 	sw	s0,28(sp)
9d002370:	00808021 	move	s0,a0
9d002374:	00a0a821 	move	s5,a1
9d002378:	00e0a021 	move	s4,a3
9d00237c:	8fb30058 	lw	s3,88(sp)
9d002380:	8fb2005c 	lw	s2,92(sp)
9d002384:	8fb10070 	lw	s1,112(sp)
	unsigned char data[5];

	data[0] = en_aa;
9d002388:	a3a60010 	sb	a2,16(sp)
	nrf24l01_write_register(nrf24l01_EN_AA, data, 1);
9d00238c:	24040001 	li	a0,1
9d002390:	27a50010 	addiu	a1,sp,16
9d002394:	0f4007f9 	jal	9d001fe4 <nrf24l01_write_register>
9d002398:	24060001 	li	a2,1

	data[0] = en_rxaddr;
9d00239c:	a3b40010 	sb	s4,16(sp)
	nrf24l01_write_register(nrf24l01_EN_RXADDR, data, 1);
9d0023a0:	24040002 	li	a0,2
9d0023a4:	27a50010 	addiu	a1,sp,16
9d0023a8:	0f4007f9 	jal	9d001fe4 <nrf24l01_write_register>
9d0023ac:	24060001 	li	a2,1

	data[0] = setup_aw;
9d0023b0:	93a20048 	lbu	v0,72(sp)
9d0023b4:	a3a20010 	sb	v0,16(sp)
	nrf24l01_write_register(nrf24l01_SETUP_AW, data, 1);
9d0023b8:	24040003 	li	a0,3
9d0023bc:	27a50010 	addiu	a1,sp,16
9d0023c0:	0f4007f9 	jal	9d001fe4 <nrf24l01_write_register>
9d0023c4:	24060001 	li	a2,1

	data[0] = setup_retr;
9d0023c8:	93a2004c 	lbu	v0,76(sp)
9d0023cc:	a3a20010 	sb	v0,16(sp)
	nrf24l01_write_register(nrf24l01_SETUP_RETR, data, 1);
9d0023d0:	24040004 	li	a0,4
9d0023d4:	27a50010 	addiu	a1,sp,16
9d0023d8:	0f4007f9 	jal	9d001fe4 <nrf24l01_write_register>
9d0023dc:	24060001 	li	a2,1

	data[0] = rf_ch;
9d0023e0:	93a20050 	lbu	v0,80(sp)
9d0023e4:	a3a20010 	sb	v0,16(sp)
	nrf24l01_write_register(nrf24l01_RF_CH, data, 1);
9d0023e8:	24040005 	li	a0,5
9d0023ec:	27a50010 	addiu	a1,sp,16
9d0023f0:	0f4007f9 	jal	9d001fe4 <nrf24l01_write_register>
9d0023f4:	24060001 	li	a2,1

	data[0] = rf_setup;
9d0023f8:	93a20054 	lbu	v0,84(sp)
9d0023fc:	a3a20010 	sb	v0,16(sp)
	nrf24l01_write_register(nrf24l01_RF_SETUP, data, 1);
9d002400:	24040006 	li	a0,6
9d002404:	27a50010 	addiu	a1,sp,16
9d002408:	0f4007f9 	jal	9d001fe4 <nrf24l01_write_register>
9d00240c:	24060001 	li	a2,1

	if(rx_addr_p0 != NULL)
9d002410:	12600006 	beqz	s3,9d00242c <nrf24l01_initialize+0xdc>
9d002414:	2404000a 	li	a0,10
void nrf24l01_set_rx_addr(unsigned char * address, unsigned int len, unsigned char rxpipenum)
{	
	if(rxpipenum > 5)
		return;
		
	nrf24l01_write_register(nrf24l01_RX_ADDR_P0 + rxpipenum, address, len);
9d002418:	02602821 	move	a1,s3
9d00241c:	0f4007f9 	jal	9d001fe4 <nrf24l01_write_register>
9d002420:	24060005 	li	a2,5
9d002424:	0b400914 	j	9d002450 <nrf24l01_initialize+0x100>
9d002428:	00000000 	nop

	if(rx_addr_p0 != NULL)
		nrf24l01_set_rx_addr(rx_addr_p0, 5, 0);
	else
	{
		data[0] = nrf24l01_RX_ADDR_P0_B0_DEFAULT_VAL;
9d00242c:	2402ffe7 	li	v0,-25
9d002430:	a3a20010 	sb	v0,16(sp)
		data[1] = nrf24l01_RX_ADDR_P0_B1_DEFAULT_VAL;
9d002434:	a3a20011 	sb	v0,17(sp)
		data[2] = nrf24l01_RX_ADDR_P0_B2_DEFAULT_VAL;
9d002438:	a3a20012 	sb	v0,18(sp)
		data[3] = nrf24l01_RX_ADDR_P0_B3_DEFAULT_VAL;
9d00243c:	a3a20013 	sb	v0,19(sp)
		data[4] = nrf24l01_RX_ADDR_P0_B4_DEFAULT_VAL;
9d002440:	a3a20014 	sb	v0,20(sp)
void nrf24l01_set_rx_addr(unsigned char * address, unsigned int len, unsigned char rxpipenum)
{	
	if(rxpipenum > 5)
		return;
		
	nrf24l01_write_register(nrf24l01_RX_ADDR_P0 + rxpipenum, address, len);
9d002444:	27a50010 	addiu	a1,sp,16
9d002448:	0f4007f9 	jal	9d001fe4 <nrf24l01_write_register>
9d00244c:	24060005 	li	a2,5
		data[4] = nrf24l01_RX_ADDR_P0_B4_DEFAULT_VAL;
		
		nrf24l01_set_rx_addr(data, 5, 0);
	}

	if(rx_addr_p1 != NULL)
9d002450:	12400006 	beqz	s2,9d00246c <nrf24l01_initialize+0x11c>
9d002454:	2404000b 	li	a0,11
void nrf24l01_set_rx_addr(unsigned char * address, unsigned int len, unsigned char rxpipenum)
{	
	if(rxpipenum > 5)
		return;
		
	nrf24l01_write_register(nrf24l01_RX_ADDR_P0 + rxpipenum, address, len);
9d002458:	02402821 	move	a1,s2
9d00245c:	0f4007f9 	jal	9d001fe4 <nrf24l01_write_register>
9d002460:	24060005 	li	a2,5
		data[4] = nrf24l01_RX_ADDR_P1_B4_DEFAULT_VAL;
		
		nrf24l01_set_rx_addr(data, 5, 1);
	}

	data[0] = rx_addr_p2;
9d002464:	0b400925 	j	9d002494 <nrf24l01_initialize+0x144>
9d002468:	93a20060 	lbu	v0,96(sp)

	if(rx_addr_p1 != NULL)
		nrf24l01_set_rx_addr(rx_addr_p1, 5, 1);
	else
	{
		data[0] = nrf24l01_RX_ADDR_P1_B0_DEFAULT_VAL;
9d00246c:	2402ffc2 	li	v0,-62
9d002470:	a3a20010 	sb	v0,16(sp)
		data[1] = nrf24l01_RX_ADDR_P1_B1_DEFAULT_VAL;
9d002474:	a3a20011 	sb	v0,17(sp)
		data[2] = nrf24l01_RX_ADDR_P1_B2_DEFAULT_VAL;
9d002478:	a3a20012 	sb	v0,18(sp)
		data[3] = nrf24l01_RX_ADDR_P1_B3_DEFAULT_VAL;
9d00247c:	a3a20013 	sb	v0,19(sp)
		data[4] = nrf24l01_RX_ADDR_P1_B4_DEFAULT_VAL;
9d002480:	a3a20014 	sb	v0,20(sp)
void nrf24l01_set_rx_addr(unsigned char * address, unsigned int len, unsigned char rxpipenum)
{	
	if(rxpipenum > 5)
		return;
		
	nrf24l01_write_register(nrf24l01_RX_ADDR_P0 + rxpipenum, address, len);
9d002484:	27a50010 	addiu	a1,sp,16
9d002488:	0f4007f9 	jal	9d001fe4 <nrf24l01_write_register>
9d00248c:	24060005 	li	a2,5
		data[4] = nrf24l01_RX_ADDR_P1_B4_DEFAULT_VAL;
		
		nrf24l01_set_rx_addr(data, 5, 1);
	}

	data[0] = rx_addr_p2;
9d002490:	93a20060 	lbu	v0,96(sp)
9d002494:	a3a20010 	sb	v0,16(sp)
void nrf24l01_set_rx_addr(unsigned char * address, unsigned int len, unsigned char rxpipenum)
{	
	if(rxpipenum > 5)
		return;
		
	nrf24l01_write_register(nrf24l01_RX_ADDR_P0 + rxpipenum, address, len);
9d002498:	2404000c 	li	a0,12
9d00249c:	27a50010 	addiu	a1,sp,16
9d0024a0:	0f4007f9 	jal	9d001fe4 <nrf24l01_write_register>
9d0024a4:	24060001 	li	a2,1
	}

	data[0] = rx_addr_p2;
	nrf24l01_set_rx_addr(data, 1, 2);

	data[0] = rx_addr_p3;
9d0024a8:	93a20064 	lbu	v0,100(sp)
9d0024ac:	a3a20010 	sb	v0,16(sp)
void nrf24l01_set_rx_addr(unsigned char * address, unsigned int len, unsigned char rxpipenum)
{	
	if(rxpipenum > 5)
		return;
		
	nrf24l01_write_register(nrf24l01_RX_ADDR_P0 + rxpipenum, address, len);
9d0024b0:	2404000d 	li	a0,13
9d0024b4:	27a50010 	addiu	a1,sp,16
9d0024b8:	0f4007f9 	jal	9d001fe4 <nrf24l01_write_register>
9d0024bc:	24060001 	li	a2,1
	nrf24l01_set_rx_addr(data, 1, 2);

	data[0] = rx_addr_p3;
	nrf24l01_set_rx_addr(data, 1, 3);

	data[0] = rx_addr_p4;
9d0024c0:	93a20068 	lbu	v0,104(sp)
9d0024c4:	a3a20010 	sb	v0,16(sp)
void nrf24l01_set_rx_addr(unsigned char * address, unsigned int len, unsigned char rxpipenum)
{	
	if(rxpipenum > 5)
		return;
		
	nrf24l01_write_register(nrf24l01_RX_ADDR_P0 + rxpipenum, address, len);
9d0024c8:	2404000e 	li	a0,14
9d0024cc:	27a50010 	addiu	a1,sp,16
9d0024d0:	0f4007f9 	jal	9d001fe4 <nrf24l01_write_register>
9d0024d4:	24060001 	li	a2,1
	nrf24l01_set_rx_addr(data, 1, 3);

	data[0] = rx_addr_p4;
	nrf24l01_set_rx_addr(data, 1, 4);

	data[0] = rx_addr_p5;
9d0024d8:	93a2006c 	lbu	v0,108(sp)
9d0024dc:	a3a20010 	sb	v0,16(sp)
void nrf24l01_set_rx_addr(unsigned char * address, unsigned int len, unsigned char rxpipenum)
{	
	if(rxpipenum > 5)
		return;
		
	nrf24l01_write_register(nrf24l01_RX_ADDR_P0 + rxpipenum, address, len);
9d0024e0:	2404000f 	li	a0,15
9d0024e4:	27a50010 	addiu	a1,sp,16
9d0024e8:	0f4007f9 	jal	9d001fe4 <nrf24l01_write_register>
9d0024ec:	24060001 	li	a2,1
	nrf24l01_set_rx_addr(data, 1, 4);

	data[0] = rx_addr_p5;
	nrf24l01_set_rx_addr(data, 1, 5);

	if(tx_addr != NULL)
9d0024f0:	12200005 	beqz	s1,9d002508 <nrf24l01_initialize+0x1b8>
9d0024f4:	02202021 	move	a0,s1
		nrf24l01_set_tx_addr(tx_addr, 5);
9d0024f8:	0f40085f 	jal	9d00217c <nrf24l01_set_tx_addr>
9d0024fc:	24050005 	li	a1,5
9d002500:	0b40094c 	j	9d002530 <nrf24l01_initialize+0x1e0>
9d002504:	93a20074 	lbu	v0,116(sp)
	else
	{
		data[0] = nrf24l01_TX_ADDR_B0_DEFAULT_VAL;
9d002508:	2402ffe7 	li	v0,-25
9d00250c:	a3a20010 	sb	v0,16(sp)
		data[1] = nrf24l01_TX_ADDR_B1_DEFAULT_VAL;
9d002510:	a3a20011 	sb	v0,17(sp)
		data[2] = nrf24l01_TX_ADDR_B2_DEFAULT_VAL;
9d002514:	a3a20012 	sb	v0,18(sp)
		data[3] = nrf24l01_TX_ADDR_B3_DEFAULT_VAL;
9d002518:	a3a20013 	sb	v0,19(sp)
		data[4] = nrf24l01_TX_ADDR_B4_DEFAULT_VAL;
9d00251c:	a3a20014 	sb	v0,20(sp)
		
		nrf24l01_set_tx_addr(data, 5);
9d002520:	27a40010 	addiu	a0,sp,16
9d002524:	0f40085f 	jal	9d00217c <nrf24l01_set_tx_addr>
9d002528:	24050005 	li	a1,5
	}

	data[0] = rx_pw_p0;
9d00252c:	93a20074 	lbu	v0,116(sp)
9d002530:	a3a20010 	sb	v0,16(sp)
	nrf24l01_write_register(nrf24l01_RX_PW_P0, data, 1);
9d002534:	24040011 	li	a0,17
9d002538:	27a50010 	addiu	a1,sp,16
9d00253c:	0f4007f9 	jal	9d001fe4 <nrf24l01_write_register>
9d002540:	24060001 	li	a2,1

	data[0] = rx_pw_p1;
9d002544:	93a20078 	lbu	v0,120(sp)
9d002548:	a3a20010 	sb	v0,16(sp)
	nrf24l01_write_register(nrf24l01_RX_PW_P1, data, 1);
9d00254c:	24040012 	li	a0,18
9d002550:	27a50010 	addiu	a1,sp,16
9d002554:	0f4007f9 	jal	9d001fe4 <nrf24l01_write_register>
9d002558:	24060001 	li	a2,1

	data[0] = rx_pw_p2;
9d00255c:	93a2007c 	lbu	v0,124(sp)
9d002560:	a3a20010 	sb	v0,16(sp)
	nrf24l01_write_register(nrf24l01_RX_PW_P2, data, 1);
9d002564:	24040013 	li	a0,19
9d002568:	27a50010 	addiu	a1,sp,16
9d00256c:	0f4007f9 	jal	9d001fe4 <nrf24l01_write_register>
9d002570:	24060001 	li	a2,1

	data[0] = rx_pw_p3;
9d002574:	93a20080 	lbu	v0,128(sp)
9d002578:	a3a20010 	sb	v0,16(sp)
	nrf24l01_write_register(nrf24l01_RX_PW_P3, data, 1);
9d00257c:	24040014 	li	a0,20
9d002580:	27a50010 	addiu	a1,sp,16
9d002584:	0f4007f9 	jal	9d001fe4 <nrf24l01_write_register>
9d002588:	24060001 	li	a2,1

	data[0] = rx_pw_p4;
9d00258c:	93a20084 	lbu	v0,132(sp)
9d002590:	a3a20010 	sb	v0,16(sp)
	nrf24l01_write_register(nrf24l01_RX_PW_P4, data, 1);
9d002594:	24040015 	li	a0,21
9d002598:	27a50010 	addiu	a1,sp,16
9d00259c:	0f4007f9 	jal	9d001fe4 <nrf24l01_write_register>
9d0025a0:	24060001 	li	a2,1

	data[0] = rx_pw_p5;
9d0025a4:	93a20088 	lbu	v0,136(sp)
9d0025a8:	a3a20010 	sb	v0,16(sp)
	nrf24l01_write_register(nrf24l01_RX_PW_P5, data, 1);
9d0025ac:	24040016 	li	a0,22
9d0025b0:	27a50010 	addiu	a1,sp,16
9d0025b4:	0f4007f9 	jal	9d001fe4 <nrf24l01_write_register>
9d0025b8:	24060001 	li	a2,1

	if((config & nrf24l01_CONFIG_PWR_UP) != 0)
9d0025bc:	32020002 	andi	v0,s0,0x2
9d0025c0:	304200ff 	andi	v0,v0,0xff
9d0025c4:	10400005 	beqz	v0,9d0025dc <nrf24l01_initialize+0x28c>
9d0025c8:	02a02021 	move	a0,s5
		nrf24l01_power_up_param(opt_rx_active_mode, config);
9d0025cc:	0f400802 	jal	9d002008 <nrf24l01_power_up_param>
9d0025d0:	02002821 	move	a1,s0
9d0025d4:	0b40097a 	j	9d0025e8 <nrf24l01_initialize+0x298>
9d0025d8:	8fbf0034 	lw	ra,52(sp)
	else
		nrf24l01_power_down_param(config);
9d0025dc:	0f400834 	jal	9d0020d0 <nrf24l01_power_down_param>
9d0025e0:	02002021 	move	a0,s0
}
9d0025e4:	8fbf0034 	lw	ra,52(sp)
9d0025e8:	8fb50030 	lw	s5,48(sp)
9d0025ec:	8fb4002c 	lw	s4,44(sp)
9d0025f0:	8fb30028 	lw	s3,40(sp)
9d0025f4:	8fb20024 	lw	s2,36(sp)
9d0025f8:	8fb10020 	lw	s1,32(sp)
9d0025fc:	8fb0001c 	lw	s0,28(sp)
9d002600:	03e00008 	jr	ra
9d002604:	27bd0038 	addiu	sp,sp,56

9d002608 <nrf24l01_initialize_debug>:
//unsigned char payload_width is the payload width for pipe 0.  All other pipes
//  are left in their default (disabled) state.
//bool enable_auto_ack controls the auto ack feature on pipe 0.  If true, auto-ack will
//  be enabled.  If false, auto-ack is disabled.
void nrf24l01_initialize_debug(bool rx, unsigned char p0_payload_width, bool enable_auto_ack)
{
9d002608:	27bdffa0 	addiu	sp,sp,-96
9d00260c:	afbf005c 	sw	ra,92(sp)
	unsigned char config;
	unsigned char en_aa;
	
	config = nrf24l01_CONFIG_DEFAULT_VAL | nrf24l01_CONFIG_PWR_UP;
9d002610:	38830001 	xori	v1,a0,0x1
		en_aa = nrf24l01_EN_AA_ENAA_NONE;
	
	if(rx == true)
		config = config | nrf24l01_CONFIG_PRIM_RX;
		
	nrf24l01_initialize(config, 
9d002614:	24020003 	li	v0,3
9d002618:	afa20010 	sw	v0,16(sp)
9d00261c:	afa20014 	sw	v0,20(sp)
9d002620:	24020002 	li	v0,2
9d002624:	afa20018 	sw	v0,24(sp)
9d002628:	2402000f 	li	v0,15
9d00262c:	afa2001c 	sw	v0,28(sp)
9d002630:	afa00020 	sw	zero,32(sp)
9d002634:	afa00024 	sw	zero,36(sp)
9d002638:	240200c3 	li	v0,195
9d00263c:	afa20028 	sw	v0,40(sp)
9d002640:	240200c4 	li	v0,196
9d002644:	afa2002c 	sw	v0,44(sp)
9d002648:	240200c5 	li	v0,197
9d00264c:	afa20030 	sw	v0,48(sp)
9d002650:	240200c6 	li	v0,198
9d002654:	afa20034 	sw	v0,52(sp)
9d002658:	afa00038 	sw	zero,56(sp)
9d00265c:	afa5003c 	sw	a1,60(sp)
9d002660:	afa00040 	sw	zero,64(sp)
9d002664:	afa00044 	sw	zero,68(sp)
9d002668:	afa00048 	sw	zero,72(sp)
9d00266c:	afa0004c 	sw	zero,76(sp)
9d002670:	afa00050 	sw	zero,80(sp)
9d002674:	2402000a 	li	v0,10
9d002678:	2404000b 	li	a0,11
9d00267c:	0043200b 	movn	a0,v0,v1
9d002680:	24050001 	li	a1,1
9d002684:	0006302b 	sltu	a2,zero,a2
9d002688:	0f4008d4 	jal	9d002350 <nrf24l01_initialize>
9d00268c:	24070003 	li	a3,3
						nrf24l01_RX_PW_P1_DEFAULT_VAL, 
						nrf24l01_RX_PW_P2_DEFAULT_VAL, 
						nrf24l01_RX_PW_P3_DEFAULT_VAL, 
						nrf24l01_RX_PW_P4_DEFAULT_VAL, 
						nrf24l01_RX_PW_P5_DEFAULT_VAL);
}
9d002690:	8fbf005c 	lw	ra,92(sp)
9d002694:	03e00008 	jr	ra
9d002698:	27bd0060 	addiu	sp,sp,96

9d00269c <nrf24l01_read_register>:
//  length for the register the address is being read from.
//unsigned int len is always the size of unsigned char * data.  For example, if data is declared as 
//  data[6], len = 6.
//returns the value of the STATUS register
unsigned char nrf24l01_read_register(unsigned char regnumber, unsigned char * data, unsigned int len)
{
9d00269c:	27bdffe8 	addiu	sp,sp,-24
9d0026a0:	afbf0014 	sw	ra,20(sp)
	return nrf24l01_execute_command(regnumber & nrf24l01_R_REGISTER_DATA, data, len, true);
9d0026a4:	3084001f 	andi	a0,a0,0x1f
9d0026a8:	0f4007db 	jal	9d001f6c <nrf24l01_execute_command>
9d0026ac:	24070001 	li	a3,1
}
9d0026b0:	8fbf0014 	lw	ra,20(sp)
9d0026b4:	03e00008 	jr	ra
9d0026b8:	27bd0018 	addiu	sp,sp,24

9d0026bc <nrf24l01_power_up>:
//  pin will be set and the 24L01 will monitor for packets.  In TX mode, the value
//  of this argument is insignificant.
//note: if the read value of the CONFIG register already has the PWR_UP bit set, this function
//  exits in order to not make an unecessary register write.
void nrf24l01_power_up(bool rx_active_mode)
{
9d0026bc:	27bdffe0 	addiu	sp,sp,-32
9d0026c0:	afbf001c 	sw	ra,28(sp)
9d0026c4:	afb00018 	sw	s0,24(sp)
9d0026c8:	00808021 	move	s0,a0
	unsigned char config;
	
	nrf24l01_read_register(nrf24l01_CONFIG, &config, 1);
9d0026cc:	00002021 	move	a0,zero
9d0026d0:	27a50010 	addiu	a1,sp,16
9d0026d4:	0f4009a7 	jal	9d00269c <nrf24l01_read_register>
9d0026d8:	24060001 	li	a2,1
	
	if((config & nrf24l01_CONFIG_PWR_UP) != 0)
9d0026dc:	93a20010 	lbu	v0,16(sp)
9d0026e0:	30430002 	andi	v1,v0,0x2
9d0026e4:	306300ff 	andi	v1,v1,0xff
9d0026e8:	1460001a 	bnez	v1,9d002754 <nrf24l01_power_up+0x98>
9d0026ec:	8fbf001c 	lw	ra,28(sp)
		return;
		
	config |= nrf24l01_CONFIG_PWR_UP;
9d0026f0:	34420002 	ori	v0,v0,0x2
9d0026f4:	a3a20010 	sb	v0,16(sp)
	
	nrf24l01_write_register(nrf24l01_CONFIG, &config, 1);
9d0026f8:	00002021 	move	a0,zero
9d0026fc:	27a50010 	addiu	a1,sp,16
9d002700:	0f4007f9 	jal	9d001fe4 <nrf24l01_write_register>
9d002704:	24060001 	li	a2,1
	
	delay_us(1500);
9d002708:	0f400d51 	jal	9d003544 <DelayUS>
9d00270c:	240405dc 	li	a0,1500
	
	if((config & nrf24l01_CONFIG_PRIM_RX) == 0)
9d002710:	93a20010 	lbu	v0,16(sp)
9d002714:	30420001 	andi	v0,v0,0x1
9d002718:	14400005 	bnez	v0,9d002730 <nrf24l01_power_up+0x74>
9d00271c:	00000000 	nop
		nrf24l01_clear_ce();
9d002720:	0f400780 	jal	9d001e00 <nrf24l01_clear_ce>
9d002724:	00000000 	nop
9d002728:	0b4009d5 	j	9d002754 <nrf24l01_power_up+0x98>
9d00272c:	8fbf001c 	lw	ra,28(sp)
	else
	{
		if(rx_active_mode != false)
9d002730:	12000005 	beqz	s0,9d002748 <nrf24l01_power_up+0x8c>
9d002734:	00000000 	nop
			nrf24l01_set_ce();
9d002738:	0f40078d 	jal	9d001e34 <nrf24l01_set_ce>
9d00273c:	00000000 	nop
9d002740:	0b4009d5 	j	9d002754 <nrf24l01_power_up+0x98>
9d002744:	8fbf001c 	lw	ra,28(sp)
		else
			nrf24l01_clear_ce();
9d002748:	0f400780 	jal	9d001e00 <nrf24l01_clear_ce>
9d00274c:	00000000 	nop
	}
}
9d002750:	8fbf001c 	lw	ra,28(sp)
9d002754:	8fb00018 	lw	s0,24(sp)
9d002758:	03e00008 	jr	ra
9d00275c:	27bd0020 	addiu	sp,sp,32

9d002760 <nrf24l01_power_down>:
//this function takes the existing contents of the CONFIG register and simply
//  clears the PWR_UP bit in the CONFIG register.
//note: if the read value of the CONFIG register already has the PWR_UP bit cleared, this 
//  function exits in order to not make an unecessary register write.
void nrf24l01_power_down()
{
9d002760:	27bdffe0 	addiu	sp,sp,-32
9d002764:	afbf001c 	sw	ra,28(sp)
	unsigned char config;
	
	nrf24l01_read_register(nrf24l01_CONFIG, &config, 1);
9d002768:	00002021 	move	a0,zero
9d00276c:	27a50010 	addiu	a1,sp,16
9d002770:	0f4009a7 	jal	9d00269c <nrf24l01_read_register>
9d002774:	24060001 	li	a2,1
	
	if((config & nrf24l01_CONFIG_PWR_UP) == 0)
9d002778:	93a20010 	lbu	v0,16(sp)
9d00277c:	30430002 	andi	v1,v0,0x2
9d002780:	306300ff 	andi	v1,v1,0xff
9d002784:	1060000a 	beqz	v1,9d0027b0 <nrf24l01_power_down+0x50>
9d002788:	8fbf001c 	lw	ra,28(sp)
		return;
	
	config &= (~nrf24l01_CONFIG_PWR_UP);
9d00278c:	7c020844 	ins	v0,zero,0x1,0x1
9d002790:	a3a20010 	sb	v0,16(sp)
	
	nrf24l01_write_register(nrf24l01_CONFIG, &config, 1);
9d002794:	00002021 	move	a0,zero
9d002798:	27a50010 	addiu	a1,sp,16
9d00279c:	0f4007f9 	jal	9d001fe4 <nrf24l01_write_register>
9d0027a0:	24060001 	li	a2,1

	nrf24l01_clear_ce();
9d0027a4:	0f400780 	jal	9d001e00 <nrf24l01_clear_ce>
9d0027a8:	00000000 	nop
}
9d0027ac:	8fbf001c 	lw	ra,28(sp)
9d0027b0:	03e00008 	jr	ra
9d0027b4:	27bd0020 	addiu	sp,sp,32

9d0027b8 <nrf24l01_set_as_rx>:
//  and not monitor for packets.  If the argument is true, the CE pin will be set 
//  and the 24L01 will monitor for packets.
//note: if the read value of the CONFIG register already has the PRIM_RX bit set, this function
//  exits in order to not make an unecessary register write.
void nrf24l01_set_as_rx(bool rx_active_mode)
{
9d0027b8:	27bdffe0 	addiu	sp,sp,-32
9d0027bc:	afbf001c 	sw	ra,28(sp)
9d0027c0:	afb00018 	sw	s0,24(sp)
9d0027c4:	00808021 	move	s0,a0
	unsigned char config;
	unsigned char status;
	
	status = nrf24l01_read_register(0, &config, 1);
9d0027c8:	00002021 	move	a0,zero
9d0027cc:	27a50010 	addiu	a1,sp,16
9d0027d0:	0f4009a7 	jal	9d00269c <nrf24l01_read_register>
9d0027d4:	24060001 	li	a2,1

	if((config & nrf24l01_CONFIG_PRIM_RX) != 0)
9d0027d8:	93a20010 	lbu	v0,16(sp)
9d0027dc:	30430001 	andi	v1,v0,0x1
9d0027e0:	14600010 	bnez	v1,9d002824 <nrf24l01_set_as_rx+0x6c>
9d0027e4:	8fbf001c 	lw	ra,28(sp)
		return;

	config |= nrf24l01_CONFIG_PRIM_RX;
9d0027e8:	34420001 	ori	v0,v0,0x1
9d0027ec:	a3a20010 	sb	v0,16(sp)
	
	nrf24l01_write_register(nrf24l01_CONFIG, &config, 1);
9d0027f0:	00002021 	move	a0,zero
9d0027f4:	27a50010 	addiu	a1,sp,16
9d0027f8:	0f4007f9 	jal	9d001fe4 <nrf24l01_write_register>
9d0027fc:	24060001 	li	a2,1

	if(rx_active_mode != false)
9d002800:	12000005 	beqz	s0,9d002818 <nrf24l01_set_as_rx+0x60>
9d002804:	00000000 	nop
		nrf24l01_set_ce();
9d002808:	0f40078d 	jal	9d001e34 <nrf24l01_set_ce>
9d00280c:	00000000 	nop
9d002810:	0b400a09 	j	9d002824 <nrf24l01_set_as_rx+0x6c>
9d002814:	8fbf001c 	lw	ra,28(sp)
	else
		nrf24l01_clear_ce();
9d002818:	0f400780 	jal	9d001e00 <nrf24l01_clear_ce>
9d00281c:	00000000 	nop
}
9d002820:	8fbf001c 	lw	ra,28(sp)
9d002824:	8fb00018 	lw	s0,24(sp)
9d002828:	03e00008 	jr	ra
9d00282c:	27bd0020 	addiu	sp,sp,32

9d002830 <nrf24l01_set_as_tx>:
//this function takes the existing contents of the CONFIG register and simply
//  clears the PRIM_RX bit in the CONFIG register.
//note: if the read value of the CONFIG register already has the PRIM_RX bit cleared, this 
//  function exits in order to not make an unecessary register write.
void nrf24l01_set_as_tx()
{
9d002830:	27bdffe0 	addiu	sp,sp,-32
9d002834:	afbf001c 	sw	ra,28(sp)
	unsigned char config;
	
	nrf24l01_read_register(nrf24l01_CONFIG, &config, 1);
9d002838:	00002021 	move	a0,zero
9d00283c:	27a50010 	addiu	a1,sp,16
9d002840:	0f4009a7 	jal	9d00269c <nrf24l01_read_register>
9d002844:	24060001 	li	a2,1
	
	if((config & nrf24l01_CONFIG_PRIM_RX) == 0)
9d002848:	93a20010 	lbu	v0,16(sp)
9d00284c:	30430001 	andi	v1,v0,0x1
9d002850:	1060000a 	beqz	v1,9d00287c <nrf24l01_set_as_tx+0x4c>
9d002854:	8fbf001c 	lw	ra,28(sp)
		return;
	
	config &= (~nrf24l01_CONFIG_PRIM_RX);
9d002858:	7c020004 	ins	v0,zero,0x0,0x1
9d00285c:	a3a20010 	sb	v0,16(sp)
	
	nrf24l01_write_register(nrf24l01_CONFIG, &config, 1);
9d002860:	00002021 	move	a0,zero
9d002864:	27a50010 	addiu	a1,sp,16
9d002868:	0f4007f9 	jal	9d001fe4 <nrf24l01_write_register>
9d00286c:	24060001 	li	a2,1

	nrf24l01_clear_ce();
9d002870:	0f400780 	jal	9d001e00 <nrf24l01_clear_ce>
9d002874:	00000000 	nop
}
9d002878:	8fbf001c 	lw	ra,28(sp)
9d00287c:	03e00008 	jr	ra
9d002880:	27bd0020 	addiu	sp,sp,32

9d002884 <nrf24l01_get_rx_pw>:
//  does nothing.
unsigned char nrf24l01_get_rx_pw(unsigned char rxpipenum)
{
	unsigned char data;
	
	if((rxpipenum > 5))
9d002884:	2c830006 	sltiu	v1,a0,6
9d002888:	1060000b 	beqz	v1,9d0028b8 <nrf24l01_get_rx_pw+0x34>
9d00288c:	00001021 	move	v0,zero
//gets the RX payload width on the pipe offset by rxpipenum
//unsigned char rxpipenum is the pipe number (zero to five) whose address is being
//	specified.  If an invalid address (greater than five) is supplied, the function
//  does nothing.
unsigned char nrf24l01_get_rx_pw(unsigned char rxpipenum)
{
9d002890:	27bdffe0 	addiu	sp,sp,-32
9d002894:	afbf001c 	sw	ra,28(sp)
	unsigned char data;
	
	if((rxpipenum > 5))
		return 0;
		
	nrf24l01_read_register(nrf24l01_RX_PW_P0 + rxpipenum, &data, 1);
9d002898:	24840011 	addiu	a0,a0,17
9d00289c:	308400ff 	andi	a0,a0,0xff
9d0028a0:	27a50010 	addiu	a1,sp,16
9d0028a4:	0f4009a7 	jal	9d00269c <nrf24l01_read_register>
9d0028a8:	24060001 	li	a2,1
	
	return data;
9d0028ac:	93a20010 	lbu	v0,16(sp)
}
9d0028b0:	8fbf001c 	lw	ra,28(sp)
9d0028b4:	27bd0020 	addiu	sp,sp,32
9d0028b8:	03e00008 	jr	ra
9d0028bc:	00000000 	nop

9d0028c0 <nrf24l01_get_config>:

//returns the value of the CONFIG register
unsigned char nrf24l01_get_config()
{
9d0028c0:	27bdffe0 	addiu	sp,sp,-32
9d0028c4:	afbf001c 	sw	ra,28(sp)
	unsigned char data;
	
	nrf24l01_read_register(nrf24l01_CONFIG, &data, 1);
9d0028c8:	00002021 	move	a0,zero
9d0028cc:	27a50010 	addiu	a1,sp,16
9d0028d0:	0f4009a7 	jal	9d00269c <nrf24l01_read_register>
9d0028d4:	24060001 	li	a2,1
	
	return data;
}
9d0028d8:	93a20010 	lbu	v0,16(sp)
9d0028dc:	8fbf001c 	lw	ra,28(sp)
9d0028e0:	03e00008 	jr	ra
9d0028e4:	27bd0020 	addiu	sp,sp,32

9d0028e8 <nrf24l01_get_rf_ch>:
	nrf24l01_write_register(nrf24l01_CONFIG, &config, 1);
}

//returns the current RF channel in RF_CH register
unsigned char nrf24l01_get_rf_ch()
{
9d0028e8:	27bdffe0 	addiu	sp,sp,-32
9d0028ec:	afbf001c 	sw	ra,28(sp)
	unsigned char data;
	
	nrf24l01_read_register(nrf24l01_RF_CH, &data, 1);
9d0028f0:	24040005 	li	a0,5
9d0028f4:	27a50010 	addiu	a1,sp,16
9d0028f8:	0f4009a7 	jal	9d00269c <nrf24l01_read_register>
9d0028fc:	24060001 	li	a2,1
	
	return data;
}
9d002900:	93a20010 	lbu	v0,16(sp)
9d002904:	8fbf001c 	lw	ra,28(sp)
9d002908:	03e00008 	jr	ra
9d00290c:	27bd0020 	addiu	sp,sp,32

9d002910 <nrf24l01_get_observe_tx>:
	nrf24l01_write_register(nrf24l01_RF_CH, &data, 1);
}

//returns the value of the OBSERVE_TX register
unsigned char nrf24l01_get_observe_tx()
{
9d002910:	27bdffe0 	addiu	sp,sp,-32
9d002914:	afbf001c 	sw	ra,28(sp)
	unsigned char data;
	
	nrf24l01_read_register(nrf24l01_OBSERVE_TX, &data, 1);
9d002918:	24040008 	li	a0,8
9d00291c:	27a50010 	addiu	a1,sp,16
9d002920:	0f4009a7 	jal	9d00269c <nrf24l01_read_register>
9d002924:	24060001 	li	a2,1
	
	return data;
}
9d002928:	93a20010 	lbu	v0,16(sp)
9d00292c:	8fbf001c 	lw	ra,28(sp)
9d002930:	03e00008 	jr	ra
9d002934:	27bd0020 	addiu	sp,sp,32

9d002938 <nrf24l01_get_plos_cnt>:

//returns the current PLOS_CNT value in OBSERVE_TX register
unsigned char nrf24l01_get_plos_cnt()
{
9d002938:	27bdffe0 	addiu	sp,sp,-32
9d00293c:	afbf001c 	sw	ra,28(sp)
	unsigned char data;
	
	nrf24l01_read_register(nrf24l01_OBSERVE_TX, &data, 1);
9d002940:	24040008 	li	a0,8
9d002944:	27a50010 	addiu	a1,sp,16
9d002948:	0f4009a7 	jal	9d00269c <nrf24l01_read_register>
9d00294c:	24060001 	li	a2,1
	
	return ((data & nrf24l01_OBSERVE_TX_PLOS_CNT) >> 4);
9d002950:	93a20010 	lbu	v0,16(sp)
}
9d002954:	00021102 	srl	v0,v0,0x4
9d002958:	8fbf001c 	lw	ra,28(sp)
9d00295c:	03e00008 	jr	ra
9d002960:	27bd0020 	addiu	sp,sp,32

9d002964 <nrf24l01_clear_plos_cnt>:

//clears the PLOS_CNT field of the OBSERVE_TX register
//this function makes a read of the current value of RF_CH and
//  simply writes it back to the register, clearing PLOS_CNT
void nrf24l01_clear_plos_cnt()
{
9d002964:	27bdffe0 	addiu	sp,sp,-32
9d002968:	afbf001c 	sw	ra,28(sp)
	unsigned char data;
	
	nrf24l01_read_register(nrf24l01_RF_CH, &data, 1);
9d00296c:	24040005 	li	a0,5
9d002970:	27a50010 	addiu	a1,sp,16
9d002974:	0f4009a7 	jal	9d00269c <nrf24l01_read_register>
9d002978:	24060001 	li	a2,1
	nrf24l01_write_register(nrf24l01_RF_CH, &data, 1);
9d00297c:	24040005 	li	a0,5
9d002980:	27a50010 	addiu	a1,sp,16
9d002984:	0f4007f9 	jal	9d001fe4 <nrf24l01_write_register>
9d002988:	24060001 	li	a2,1
}
9d00298c:	8fbf001c 	lw	ra,28(sp)
9d002990:	03e00008 	jr	ra
9d002994:	27bd0020 	addiu	sp,sp,32

9d002998 <nrf24l01_get_arc_cnt>:
	nrf24l01_write_register(nrf24l01_RF_CH, &rf_ch, 1);
}

//returns the current ARC_CNT value in OBSERVE_TX register
unsigned char nrf24l01_get_arc_cnt()
{
9d002998:	27bdffe0 	addiu	sp,sp,-32
9d00299c:	afbf001c 	sw	ra,28(sp)
	unsigned char data;
	
	nrf24l01_read_register(nrf24l01_OBSERVE_TX, &data, 1);
9d0029a0:	24040008 	li	a0,8
9d0029a4:	27a50010 	addiu	a1,sp,16
9d0029a8:	0f4009a7 	jal	9d00269c <nrf24l01_read_register>
9d0029ac:	24060001 	li	a2,1
	
	return (data & nrf24l01_OBSERVE_TX_ARC_CNT);
9d0029b0:	93a20010 	lbu	v0,16(sp)
}
9d0029b4:	3042000f 	andi	v0,v0,0xf
9d0029b8:	8fbf001c 	lw	ra,28(sp)
9d0029bc:	03e00008 	jr	ra
9d0029c0:	27bd0020 	addiu	sp,sp,32

9d0029c4 <nrf24l01_aa_enabled>:
//returns true if auto-ack is enabled on the pipe that is offset by rxpipenum
//unsigned char rxpipenum is the pipe number (zero to five) whose address is being
//	specified.  If an invalid address (greater than five) is supplied, the function
//  returns false.
bool nrf24l01_aa_enabled(unsigned char rxpipenum)
{
9d0029c4:	27bdffe0 	addiu	sp,sp,-32
9d0029c8:	afbf001c 	sw	ra,28(sp)
9d0029cc:	afb00018 	sw	s0,24(sp)
9d0029d0:	00808021 	move	s0,a0
	unsigned char data;
	
	if(rxpipenum > 5)
9d0029d4:	2c830006 	sltiu	v1,a0,6
9d0029d8:	10600009 	beqz	v1,9d002a00 <nrf24l01_aa_enabled+0x3c>
9d0029dc:	00001021 	move	v0,zero
		return false;
		
	nrf24l01_read_register(nrf24l01_EN_AA, &data, 1);
9d0029e0:	24040001 	li	a0,1
9d0029e4:	27a50010 	addiu	a1,sp,16
9d0029e8:	0f4009a7 	jal	9d00269c <nrf24l01_read_register>
9d0029ec:	24060001 	li	a2,1
	
	return (data & (0x01 << rxpipenum));
9d0029f0:	24020001 	li	v0,1
9d0029f4:	02028004 	sllv	s0,v0,s0
9d0029f8:	93a30010 	lbu	v1,16(sp)
9d0029fc:	02031024 	and	v0,s0,v1
}
9d002a00:	8fbf001c 	lw	ra,28(sp)
9d002a04:	8fb00018 	lw	s0,24(sp)
9d002a08:	03e00008 	jr	ra
9d002a0c:	27bd0020 	addiu	sp,sp,32

9d002a10 <nrf24l01_aa_enable>:

//enables auto-ack is enabled on the pipe that is offset by rxpipenum
//unsigned char rxpipenum is the pipe number (zero to five) whose address is being
//	does nothing.
void nrf24l01_aa_enable(unsigned char rxpipenum)
{
9d002a10:	27bdffe0 	addiu	sp,sp,-32
9d002a14:	afbf001c 	sw	ra,28(sp)
9d002a18:	afb00018 	sw	s0,24(sp)
	unsigned char data;
	
	if(rxpipenum > 5)
9d002a1c:	2c820006 	sltiu	v0,a0,6
9d002a20:	10400012 	beqz	v0,9d002a6c <nrf24l01_aa_enable+0x5c>
9d002a24:	00808021 	move	s0,a0
		return;
		
	nrf24l01_read_register(nrf24l01_EN_AA, &data, 1);
9d002a28:	24040001 	li	a0,1
9d002a2c:	27a50010 	addiu	a1,sp,16
9d002a30:	0f4009a7 	jal	9d00269c <nrf24l01_read_register>
9d002a34:	24060001 	li	a2,1
	
	if((data & (0x01 << rxpipenum)) != 0)
9d002a38:	93a20010 	lbu	v0,16(sp)
9d002a3c:	02021807 	srav	v1,v0,s0
9d002a40:	30630001 	andi	v1,v1,0x1
9d002a44:	1460000a 	bnez	v1,9d002a70 <nrf24l01_aa_enable+0x60>
9d002a48:	8fbf001c 	lw	ra,28(sp)
		return;
	
	data |= 0x01 << rxpipenum;
9d002a4c:	24030001 	li	v1,1
9d002a50:	02038004 	sllv	s0,v1,s0
9d002a54:	02021025 	or	v0,s0,v0
9d002a58:	a3a20010 	sb	v0,16(sp)
		
	nrf24l01_write_register(nrf24l01_EN_AA, &data, 1);
9d002a5c:	24040001 	li	a0,1
9d002a60:	27a50010 	addiu	a1,sp,16
9d002a64:	0f4007f9 	jal	9d001fe4 <nrf24l01_write_register>
9d002a68:	24060001 	li	a2,1
}
9d002a6c:	8fbf001c 	lw	ra,28(sp)
9d002a70:	8fb00018 	lw	s0,24(sp)
9d002a74:	03e00008 	jr	ra
9d002a78:	27bd0020 	addiu	sp,sp,32

9d002a7c <nrf24l01_aa_disable>:

//disables auto-ack is enabled on the pipe that is offset by rxpipenum
//unsigned char rxpipenum is the pipe number (zero to five) whose address is being
//	does nothing.
void nrf24l01_aa_disable(unsigned char rxpipenum)
{
9d002a7c:	27bdffe0 	addiu	sp,sp,-32
9d002a80:	afbf001c 	sw	ra,28(sp)
9d002a84:	afb00018 	sw	s0,24(sp)
	unsigned char data;
	
	if(rxpipenum > 5)
9d002a88:	2c820006 	sltiu	v0,a0,6
9d002a8c:	10400013 	beqz	v0,9d002adc <nrf24l01_aa_disable+0x60>
9d002a90:	00808021 	move	s0,a0
		return;
		
	nrf24l01_read_register(nrf24l01_EN_AA, &data, 1);
9d002a94:	24040001 	li	a0,1
9d002a98:	27a50010 	addiu	a1,sp,16
9d002a9c:	0f4009a7 	jal	9d00269c <nrf24l01_read_register>
9d002aa0:	24060001 	li	a2,1
	
	if((data & (0x01 << rxpipenum)) == 0)
9d002aa4:	93a20010 	lbu	v0,16(sp)
9d002aa8:	02021807 	srav	v1,v0,s0
9d002aac:	30630001 	andi	v1,v1,0x1
9d002ab0:	1060000b 	beqz	v1,9d002ae0 <nrf24l01_aa_disable+0x64>
9d002ab4:	8fbf001c 	lw	ra,28(sp)
		return;
	
	data &= ~(0x01 << rxpipenum);
9d002ab8:	24030001 	li	v1,1
9d002abc:	02038004 	sllv	s0,v1,s0
9d002ac0:	00108027 	nor	s0,zero,s0
9d002ac4:	02021024 	and	v0,s0,v0
9d002ac8:	a3a20010 	sb	v0,16(sp)
		
	nrf24l01_write_register(nrf24l01_EN_AA, &data, 1);
9d002acc:	24040001 	li	a0,1
9d002ad0:	27a50010 	addiu	a1,sp,16
9d002ad4:	0f4007f9 	jal	9d001fe4 <nrf24l01_write_register>
9d002ad8:	24060001 	li	a2,1
}
9d002adc:	8fbf001c 	lw	ra,28(sp)
9d002ae0:	8fb00018 	lw	s0,24(sp)
9d002ae4:	03e00008 	jr	ra
9d002ae8:	27bd0020 	addiu	sp,sp,32

9d002aec <nrf24l01_rx_pipe_enabled>:
//returns true if the pipe is enabled that is offset by rxpipenum
//unsigned char rxpipenum is the pipe number (zero to five) whose address is being
//	specified.  If an invalid address (greater than five) is supplied, the function
//  returns false.
bool nrf24l01_rx_pipe_enabled(unsigned char rxpipenum)
{
9d002aec:	27bdffe0 	addiu	sp,sp,-32
9d002af0:	afbf001c 	sw	ra,28(sp)
9d002af4:	afb00018 	sw	s0,24(sp)
9d002af8:	00808021 	move	s0,a0
	unsigned char data;
	
	if((rxpipenum > 5))
9d002afc:	2c830006 	sltiu	v1,a0,6
9d002b00:	10600009 	beqz	v1,9d002b28 <nrf24l01_rx_pipe_enabled+0x3c>
9d002b04:	00001021 	move	v0,zero
		return false;
		
	nrf24l01_read_register(nrf24l01_EN_RXADDR, &data, 1);
9d002b08:	24040002 	li	a0,2
9d002b0c:	27a50010 	addiu	a1,sp,16
9d002b10:	0f4009a7 	jal	9d00269c <nrf24l01_read_register>
9d002b14:	24060001 	li	a2,1
	
	return (data & (0x01 << rxpipenum));
9d002b18:	24020001 	li	v0,1
9d002b1c:	02028004 	sllv	s0,v0,s0
9d002b20:	93a30010 	lbu	v1,16(sp)
9d002b24:	02031024 	and	v0,s0,v1
}
9d002b28:	8fbf001c 	lw	ra,28(sp)
9d002b2c:	8fb00018 	lw	s0,24(sp)
9d002b30:	03e00008 	jr	ra
9d002b34:	27bd0020 	addiu	sp,sp,32

9d002b38 <nrf24l01_rx_pipe_enable>:
//enables the pipe that is offset by rxpipenum
//unsigned char rxpipenum is the pipe number (zero to five) whose address is being
//	specified.  If an invalid address (greater than five) is supplied, the function
//  does nothing.
void nrf24l01_rx_pipe_enable(unsigned char rxpipenum)
{
9d002b38:	27bdffe0 	addiu	sp,sp,-32
9d002b3c:	afbf001c 	sw	ra,28(sp)
9d002b40:	afb00018 	sw	s0,24(sp)
	unsigned char data;
	
	if(rxpipenum > 5)
9d002b44:	2c820006 	sltiu	v0,a0,6
9d002b48:	10400012 	beqz	v0,9d002b94 <nrf24l01_rx_pipe_enable+0x5c>
9d002b4c:	00808021 	move	s0,a0
		return;
		
	nrf24l01_read_register(nrf24l01_EN_RXADDR, &data, 1);
9d002b50:	24040002 	li	a0,2
9d002b54:	27a50010 	addiu	a1,sp,16
9d002b58:	0f4009a7 	jal	9d00269c <nrf24l01_read_register>
9d002b5c:	24060001 	li	a2,1
	
	if((data & (0x01 << rxpipenum)) != 0)
9d002b60:	93a20010 	lbu	v0,16(sp)
9d002b64:	02021807 	srav	v1,v0,s0
9d002b68:	30630001 	andi	v1,v1,0x1
9d002b6c:	1460000a 	bnez	v1,9d002b98 <nrf24l01_rx_pipe_enable+0x60>
9d002b70:	8fbf001c 	lw	ra,28(sp)
		return;
	
	data |= 0x01 << rxpipenum;
9d002b74:	24030001 	li	v1,1
9d002b78:	02038004 	sllv	s0,v1,s0
9d002b7c:	02021025 	or	v0,s0,v0
9d002b80:	a3a20010 	sb	v0,16(sp)
		
	nrf24l01_write_register(nrf24l01_EN_RXADDR, &data, 1);
9d002b84:	24040002 	li	a0,2
9d002b88:	27a50010 	addiu	a1,sp,16
9d002b8c:	0f4007f9 	jal	9d001fe4 <nrf24l01_write_register>
9d002b90:	24060001 	li	a2,1
}
9d002b94:	8fbf001c 	lw	ra,28(sp)
9d002b98:	8fb00018 	lw	s0,24(sp)
9d002b9c:	03e00008 	jr	ra
9d002ba0:	27bd0020 	addiu	sp,sp,32

9d002ba4 <nrf24l01_rx_pipe_disable>:
//disables the pipe that is offset by rxpipenum
//unsigned char rxpipenum is the pipe number (zero to five) whose address is being
//	specified.  If an invalid address (greater than five) is supplied, the function
//  does nothing.
void nrf24l01_rx_pipe_disable(unsigned char rxpipenum)
{
9d002ba4:	27bdffe0 	addiu	sp,sp,-32
9d002ba8:	afbf001c 	sw	ra,28(sp)
9d002bac:	afb00018 	sw	s0,24(sp)
	unsigned char data;
	
	if(rxpipenum > 5)
9d002bb0:	2c820006 	sltiu	v0,a0,6
9d002bb4:	10400013 	beqz	v0,9d002c04 <nrf24l01_rx_pipe_disable+0x60>
9d002bb8:	00808021 	move	s0,a0
		return;
		
	nrf24l01_read_register(nrf24l01_EN_RXADDR, &data, 1);
9d002bbc:	24040002 	li	a0,2
9d002bc0:	27a50010 	addiu	a1,sp,16
9d002bc4:	0f4009a7 	jal	9d00269c <nrf24l01_read_register>
9d002bc8:	24060001 	li	a2,1
	
	if((data & (0x01 << rxpipenum)) == 0)
9d002bcc:	93a20010 	lbu	v0,16(sp)
9d002bd0:	02021807 	srav	v1,v0,s0
9d002bd4:	30630001 	andi	v1,v1,0x1
9d002bd8:	1060000b 	beqz	v1,9d002c08 <nrf24l01_rx_pipe_disable+0x64>
9d002bdc:	8fbf001c 	lw	ra,28(sp)
		return;
	
	data &= ~(0x01 << rxpipenum);
9d002be0:	24030001 	li	v1,1
9d002be4:	02038004 	sllv	s0,v1,s0
9d002be8:	00108027 	nor	s0,zero,s0
9d002bec:	02021024 	and	v0,s0,v0
9d002bf0:	a3a20010 	sb	v0,16(sp)
		
	nrf24l01_write_register(nrf24l01_EN_RXADDR, &data, 1);
9d002bf4:	24040002 	li	a0,2
9d002bf8:	27a50010 	addiu	a1,sp,16
9d002bfc:	0f4007f9 	jal	9d001fe4 <nrf24l01_write_register>
9d002c00:	24060001 	li	a2,1
}
9d002c04:	8fbf001c 	lw	ra,28(sp)
9d002c08:	8fb00018 	lw	s0,24(sp)
9d002c0c:	03e00008 	jr	ra
9d002c10:	27bd0020 	addiu	sp,sp,32

9d002c14 <nrf24l01_cd_active>:

//returns the status of the CD register (true if carrier detect [CD] is
//  active, false if not)
bool nrf24l01_cd_active()
{
9d002c14:	27bdffe0 	addiu	sp,sp,-32
9d002c18:	afbf001c 	sw	ra,28(sp)
	unsigned char data;
	
	nrf24l01_read_register(nrf24l01_CD, &data, 1);
9d002c1c:	24040009 	li	a0,9
9d002c20:	27a50010 	addiu	a1,sp,16
9d002c24:	0f4009a7 	jal	9d00269c <nrf24l01_read_register>
9d002c28:	24060001 	li	a2,1
	
	return data;
}
9d002c2c:	93a20010 	lbu	v0,16(sp)
9d002c30:	8fbf001c 	lw	ra,28(sp)
9d002c34:	03e00008 	jr	ra
9d002c38:	27bd0020 	addiu	sp,sp,32

9d002c3c <nrf24l01_get_fifo_status>:

//returns the value of the FIFO_STATUS register
unsigned char nrf24l01_get_fifo_status()
{
9d002c3c:	27bdffe0 	addiu	sp,sp,-32
9d002c40:	afbf001c 	sw	ra,28(sp)
	unsigned char data;
	
	nrf24l01_read_register(nrf24l01_FIFO_STATUS, &data, 1);
9d002c44:	24040017 	li	a0,23
9d002c48:	27a50010 	addiu	a1,sp,16
9d002c4c:	0f4009a7 	jal	9d00269c <nrf24l01_read_register>
9d002c50:	24060001 	li	a2,1
	
	return data;
}
9d002c54:	93a20010 	lbu	v0,16(sp)
9d002c58:	8fbf001c 	lw	ra,28(sp)
9d002c5c:	03e00008 	jr	ra
9d002c60:	27bd0020 	addiu	sp,sp,32

9d002c64 <nrf24l01_fifo_tx_reuse>:
	return nrf24l01_nop();
}

//returns true if TX_REUSE bit in FIFO_STATUS register is set, false otherwise
bool nrf24l01_fifo_tx_reuse()
{
9d002c64:	27bdffe0 	addiu	sp,sp,-32
9d002c68:	afbf001c 	sw	ra,28(sp)
	unsigned char data;
	
	nrf24l01_read_register(nrf24l01_FIFO_STATUS, &data, 1);
9d002c6c:	24040017 	li	a0,23
9d002c70:	27a50010 	addiu	a1,sp,16
9d002c74:	0f4009a7 	jal	9d00269c <nrf24l01_read_register>
9d002c78:	24060001 	li	a2,1
	
	return (bool)(data & nrf24l01_FIFO_STATUS_TX_REUSE);
9d002c7c:	93a20010 	lbu	v0,16(sp)
}
9d002c80:	30420040 	andi	v0,v0,0x40
9d002c84:	8fbf001c 	lw	ra,28(sp)
9d002c88:	03e00008 	jr	ra
9d002c8c:	27bd0020 	addiu	sp,sp,32

9d002c90 <nrf24l01_fifo_tx_full>:

//returns true if TX_FULL bit in FIFO_STATUS register is set, false otherwise
bool nrf24l01_fifo_tx_full()
{
9d002c90:	27bdffe0 	addiu	sp,sp,-32
9d002c94:	afbf001c 	sw	ra,28(sp)
	unsigned char data;
	
	nrf24l01_read_register(nrf24l01_FIFO_STATUS, &data, 1);
9d002c98:	24040017 	li	a0,23
9d002c9c:	27a50010 	addiu	a1,sp,16
9d002ca0:	0f4009a7 	jal	9d00269c <nrf24l01_read_register>
9d002ca4:	24060001 	li	a2,1
	
	return (bool)(data & nrf24l01_FIFO_STATUS_TX_FULL);
9d002ca8:	93a20010 	lbu	v0,16(sp)
}
9d002cac:	30420020 	andi	v0,v0,0x20
9d002cb0:	8fbf001c 	lw	ra,28(sp)
9d002cb4:	03e00008 	jr	ra
9d002cb8:	27bd0020 	addiu	sp,sp,32

9d002cbc <nrf24l01_fifo_tx_empty>:

//returns true if TX_EMPTY bit in FIFO_STATUS register is set, false otherwise
bool nrf24l01_fifo_tx_empty()
{
9d002cbc:	27bdffe0 	addiu	sp,sp,-32
9d002cc0:	afbf001c 	sw	ra,28(sp)
	unsigned char data;
	
	nrf24l01_read_register(nrf24l01_FIFO_STATUS, &data, 1);
9d002cc4:	24040017 	li	a0,23
9d002cc8:	27a50010 	addiu	a1,sp,16
9d002ccc:	0f4009a7 	jal	9d00269c <nrf24l01_read_register>
9d002cd0:	24060001 	li	a2,1
	
	return (bool)(data & nrf24l01_FIFO_STATUS_TX_EMPTY);
9d002cd4:	93a20010 	lbu	v0,16(sp)
}
9d002cd8:	30420010 	andi	v0,v0,0x10
9d002cdc:	8fbf001c 	lw	ra,28(sp)
9d002ce0:	03e00008 	jr	ra
9d002ce4:	27bd0020 	addiu	sp,sp,32

9d002ce8 <nrf24l01_fifo_rx_full>:

//returns true if RX_FULL bit in FIFO_STATUS register is set, false otherwise
bool nrf24l01_fifo_rx_full()
{
9d002ce8:	27bdffe0 	addiu	sp,sp,-32
9d002cec:	afbf001c 	sw	ra,28(sp)
	unsigned char data;
	
	nrf24l01_read_register(nrf24l01_FIFO_STATUS, &data, 1);
9d002cf0:	24040017 	li	a0,23
9d002cf4:	27a50010 	addiu	a1,sp,16
9d002cf8:	0f4009a7 	jal	9d00269c <nrf24l01_read_register>
9d002cfc:	24060001 	li	a2,1
	
	return (bool)(data & nrf24l01_FIFO_STATUS_RX_FULL);
9d002d00:	93a20010 	lbu	v0,16(sp)
}
9d002d04:	30420002 	andi	v0,v0,0x2
9d002d08:	8fbf001c 	lw	ra,28(sp)
9d002d0c:	03e00008 	jr	ra
9d002d10:	27bd0020 	addiu	sp,sp,32

9d002d14 <nrf24l01_fifo_rx_empty>:

//returns true if RX_EMPTYE bit in FIFO_STATUS register is set, false otherwise
bool nrf24l01_fifo_rx_empty()
{
9d002d14:	27bdffe0 	addiu	sp,sp,-32
9d002d18:	afbf001c 	sw	ra,28(sp)
	unsigned char data;
	
	nrf24l01_read_register(nrf24l01_FIFO_STATUS, &data, 1);
9d002d1c:	24040017 	li	a0,23
9d002d20:	27a50010 	addiu	a1,sp,16
9d002d24:	0f4009a7 	jal	9d00269c <nrf24l01_read_register>
9d002d28:	24060001 	li	a2,1
	
	return (bool)(data & nrf24l01_FIFO_STATUS_RX_EMPTY);
9d002d2c:	93a20010 	lbu	v0,16(sp)
}
9d002d30:	30420001 	andi	v0,v0,0x1
9d002d34:	8fbf001c 	lw	ra,28(sp)
9d002d38:	03e00008 	jr	ra
9d002d3c:	27bd0020 	addiu	sp,sp,32

9d002d40 <nrf24l01_get_all_registers>:
	nrf24l01_irq_clear_all();
}

//unsigned char * data must be at least 35 bytes long
void nrf24l01_get_all_registers(unsigned char * data)
{
9d002d40:	27bdffd0 	addiu	sp,sp,-48
9d002d44:	afbf002c 	sw	ra,44(sp)
9d002d48:	afb40028 	sw	s4,40(sp)
9d002d4c:	afb30024 	sw	s3,36(sp)
9d002d50:	afb20020 	sw	s2,32(sp)
9d002d54:	afb1001c 	sw	s1,28(sp)
9d002d58:	afb00018 	sw	s0,24(sp)
9d002d5c:	00808821 	move	s1,a0
	unsigned int outer;
	unsigned int inner;
	unsigned int dataloc = 0;
9d002d60:	00008021 	move	s0,zero
	unsigned char buffer[5];
	
	for(outer = 0; outer <= 0x17; outer++)
9d002d64:	00009021 	move	s2,zero
	{
		nrf24l01_read_register(outer, buffer, 5);
		
		for(inner = 0; inner < 5; inner++)
		{
			if(inner >= 1 && (outer != 0x0A && outer != 0x0B && outer != 0x10))
9d002d68:	24140010 	li	s4,16
	unsigned int outer;
	unsigned int inner;
	unsigned int dataloc = 0;
	unsigned char buffer[5];
	
	for(outer = 0; outer <= 0x17; outer++)
9d002d6c:	24130018 	li	s3,24
	{
		nrf24l01_read_register(outer, buffer, 5);
9d002d70:	324400ff 	andi	a0,s2,0xff
9d002d74:	27a50010 	addiu	a1,sp,16
9d002d78:	0f4009a7 	jal	9d00269c <nrf24l01_read_register>
9d002d7c:	24060005 	li	a2,5
9d002d80:	27a50010 	addiu	a1,sp,16
9d002d84:	02301021 	addu	v0,s1,s0
9d002d88:	26100001 	addiu	s0,s0,1
9d002d8c:	24030001 	li	v1,1
		
		for(inner = 0; inner < 5; inner++)
		{
			if(inner >= 1 && (outer != 0x0A && outer != 0x0B && outer != 0x10))
9d002d90:	24080001 	li	t0,1
9d002d94:	2647fff6 	addiu	a3,s2,-10
9d002d98:	0b400b6c 	j	9d002db0 <nrf24l01_get_all_registers+0x70>
9d002d9c:	2ce70002 	sltiu	a3,a3,2
9d002da0:	24630001 	addiu	v1,v1,1
9d002da4:	24a50001 	addiu	a1,a1,1
9d002da8:	24420001 	addiu	v0,v0,1
9d002dac:	26100001 	addiu	s0,s0,1
9d002db0:	10680010 	beq	v1,t0,9d002df4 <nrf24l01_get_all_registers+0xb4>
9d002db4:	00512023 	subu	a0,v0,s1
9d002db8:	54e00004 	bnezl	a3,9d002dcc <nrf24l01_get_all_registers+0x8c>
9d002dbc:	90a40000 	lbu	a0,0(a1)
9d002dc0:	56540007 	bnel	s2,s4,9d002de0 <nrf24l01_get_all_registers+0xa0>
9d002dc4:	00808021 	move	s0,a0
				break;
				
			data[dataloc] = buffer[inner];
9d002dc8:	90a40000 	lbu	a0,0(a1)
	
	for(outer = 0; outer <= 0x17; outer++)
	{
		nrf24l01_read_register(outer, buffer, 5);
		
		for(inner = 0; inner < 5; inner++)
9d002dcc:	2c660005 	sltiu	a2,v1,5
9d002dd0:	14c0fff3 	bnez	a2,9d002da0 <nrf24l01_get_all_registers+0x60>
9d002dd4:	a0440000 	sb	a0,0(v0)
	unsigned int outer;
	unsigned int inner;
	unsigned int dataloc = 0;
	unsigned char buffer[5];
	
	for(outer = 0; outer <= 0x17; outer++)
9d002dd8:	0b400b79 	j	9d002de4 <nrf24l01_get_all_registers+0xa4>
9d002ddc:	26520001 	addiu	s2,s2,1
9d002de0:	26520001 	addiu	s2,s2,1
9d002de4:	5653ffe3 	bnel	s2,s3,9d002d74 <nrf24l01_get_all_registers+0x34>
9d002de8:	324400ff 	andi	a0,s2,0xff
9d002dec:	0b400b80 	j	9d002e00 <nrf24l01_get_all_registers+0xc0>
9d002df0:	8fbf002c 	lw	ra,44(sp)
		for(inner = 0; inner < 5; inner++)
		{
			if(inner >= 1 && (outer != 0x0A && outer != 0x0B && outer != 0x10))
				break;
				
			data[dataloc] = buffer[inner];
9d002df4:	90a40000 	lbu	a0,0(a1)
9d002df8:	0b400b68 	j	9d002da0 <nrf24l01_get_all_registers+0x60>
9d002dfc:	a0440000 	sb	a0,0(v0)
			dataloc++;
		}
	}
}
9d002e00:	8fb40028 	lw	s4,40(sp)
9d002e04:	8fb30024 	lw	s3,36(sp)
9d002e08:	8fb20020 	lw	s2,32(sp)
9d002e0c:	8fb1001c 	lw	s1,28(sp)
9d002e10:	8fb00018 	lw	s0,24(sp)
9d002e14:	03e00008 	jr	ra
9d002e18:	27bd0030 	addiu	sp,sp,48

9d002e1c <nrf24l01_write_tx_payload>:
//	according to the payload length specified by the receiving nrf24l01).
//if bool transmit is true, the nrf24l01 immediately transmits the data in the payload.
//	if false, the user must use the nrf24l01_transmit() function to send the payload.
//returns the value of the STATUS register
unsigned char nrf24l01_write_tx_payload(unsigned char * data, unsigned int len, bool transmit)
{
9d002e1c:	27bdffe0 	addiu	sp,sp,-32
9d002e20:	afbf001c 	sw	ra,28(sp)
9d002e24:	afb10018 	sw	s1,24(sp)
9d002e28:	afb00014 	sw	s0,20(sp)
9d002e2c:	00801821 	move	v1,a0
9d002e30:	00a01021 	move	v0,a1
9d002e34:	00c08821 	move	s1,a2
	unsigned char status;
	
	status = nrf24l01_execute_command(nrf24l01_W_TX_PAYLOAD, data, len, false);
9d002e38:	240400a0 	li	a0,160
9d002e3c:	00602821 	move	a1,v1
9d002e40:	00403021 	move	a2,v0
9d002e44:	0f4007db 	jal	9d001f6c <nrf24l01_execute_command>
9d002e48:	00003821 	move	a3,zero
9d002e4c:	00408021 	move	s0,v0
	
	if(transmit == true)
9d002e50:	24020001 	li	v0,1
9d002e54:	16220004 	bne	s1,v0,9d002e68 <nrf24l01_write_tx_payload+0x4c>
9d002e58:	02001021 	move	v0,s0
		nrf24l01_transmit();
9d002e5c:	0f40079a 	jal	9d001e68 <nrf24l01_transmit>
9d002e60:	00000000 	nop
	
	return status;
}
9d002e64:	02001021 	move	v0,s0
9d002e68:	8fbf001c 	lw	ra,28(sp)
9d002e6c:	8fb10018 	lw	s1,24(sp)
9d002e70:	8fb00014 	lw	s0,20(sp)
9d002e74:	03e00008 	jr	ra
9d002e78:	27bd0020 	addiu	sp,sp,32

9d002e7c <nrf24l01_read_rx_payload>:
//	initialized by the user.
//unsigned int len is the length of the payload being clocked out of the nrf24l01 (this
//	should be sized according to the payload length specified to the nrf24l01).
//returns the value of the STATUS register
unsigned char nrf24l01_read_rx_payload(unsigned char * data, unsigned int len)
{
9d002e7c:	27bdffe0 	addiu	sp,sp,-32
9d002e80:	afbf001c 	sw	ra,28(sp)
9d002e84:	afb10018 	sw	s1,24(sp)
9d002e88:	afb00014 	sw	s0,20(sp)
9d002e8c:	00808821 	move	s1,a0
	unsigned char status;
	
	nrf24l01_clear_ce();
9d002e90:	0f400780 	jal	9d001e00 <nrf24l01_clear_ce>
9d002e94:	00a08021 	move	s0,a1
	status = nrf24l01_execute_command(nrf24l01_R_RX_PAYLOAD, data, len, true);
9d002e98:	24040061 	li	a0,97
9d002e9c:	02202821 	move	a1,s1
9d002ea0:	02003021 	move	a2,s0
9d002ea4:	0f4007db 	jal	9d001f6c <nrf24l01_execute_command>
9d002ea8:	24070001 	li	a3,1
	nrf24l01_set_ce();
9d002eac:	0f40078d 	jal	9d001e34 <nrf24l01_set_ce>
9d002eb0:	00408021 	move	s0,v0
	
	return status;
}
9d002eb4:	02001021 	move	v0,s0
9d002eb8:	8fbf001c 	lw	ra,28(sp)
9d002ebc:	8fb10018 	lw	s1,24(sp)
9d002ec0:	8fb00014 	lw	s0,20(sp)
9d002ec4:	03e00008 	jr	ra
9d002ec8:	27bd0020 	addiu	sp,sp,32

9d002ecc <nrf24l01_flush_tx>:

//executes the FLUSH_TX SPI operation
//this funciton empties the contents of the TX FIFO
//returns the value of the STATUS register
unsigned char nrf24l01_flush_tx()
{
9d002ecc:	27bdffe8 	addiu	sp,sp,-24
9d002ed0:	afbf0014 	sw	ra,20(sp)
	return nrf24l01_execute_command(nrf24l01_FLUSH_TX, NULL, 0, true);
9d002ed4:	240400e1 	li	a0,225
9d002ed8:	00002821 	move	a1,zero
9d002edc:	00003021 	move	a2,zero
9d002ee0:	0f4007db 	jal	9d001f6c <nrf24l01_execute_command>
9d002ee4:	24070001 	li	a3,1
}
9d002ee8:	8fbf0014 	lw	ra,20(sp)
9d002eec:	03e00008 	jr	ra
9d002ef0:	27bd0018 	addiu	sp,sp,24

9d002ef4 <nrf24l01_flush_rx>:

//executes the FLUSH_RX SPI operation
//this funciton empties the contents of the RX FIFO
//returns the value of the STATUS register
unsigned char nrf24l01_flush_rx()
{
9d002ef4:	27bdffe8 	addiu	sp,sp,-24
9d002ef8:	afbf0014 	sw	ra,20(sp)
	return nrf24l01_execute_command(nrf24l01_FLUSH_RX, NULL, 0, true);
9d002efc:	240400e2 	li	a0,226
9d002f00:	00002821 	move	a1,zero
9d002f04:	00003021 	move	a2,zero
9d002f08:	0f4007db 	jal	9d001f6c <nrf24l01_execute_command>
9d002f0c:	24070001 	li	a3,1
}
9d002f10:	8fbf0014 	lw	ra,20(sp)
9d002f14:	03e00008 	jr	ra
9d002f18:	27bd0018 	addiu	sp,sp,24

9d002f1c <nrf24l01_clear_flush>:
	return ((status & 0xE) >> 1);
}

//flush both fifos and clear interrupts
void nrf24l01_clear_flush()
{
9d002f1c:	27bdffe8 	addiu	sp,sp,-24
9d002f20:	afbf0014 	sw	ra,20(sp)
	nrf24l01_flush_rx();
9d002f24:	0f400bbd 	jal	9d002ef4 <nrf24l01_flush_rx>
9d002f28:	00000000 	nop
	nrf24l01_flush_tx();
9d002f2c:	0f400bb3 	jal	9d002ecc <nrf24l01_flush_tx>
9d002f30:	00000000 	nop
	nrf24l01_irq_clear_all();
9d002f34:	0f4008a8 	jal	9d0022a0 <nrf24l01_irq_clear_all>
9d002f38:	00000000 	nop
}
9d002f3c:	8fbf0014 	lw	ra,20(sp)
9d002f40:	03e00008 	jr	ra
9d002f44:	27bd0018 	addiu	sp,sp,24

9d002f48 <nrf24l01_reuse_tx_pl>:

//executes the REUSE_TX_PL SPI operation
//this funciton allows the user to constantly send a packet repeatedly when issued.
//returns the value of the STATUS register
unsigned char nrf24l01_reuse_tx_pl()
{
9d002f48:	27bdffe8 	addiu	sp,sp,-24
9d002f4c:	afbf0014 	sw	ra,20(sp)
	return nrf24l01_execute_command(nrf24l01_REUSE_TX_PL, NULL, 0, true);
9d002f50:	240400e3 	li	a0,227
9d002f54:	00002821 	move	a1,zero
9d002f58:	00003021 	move	a2,zero
9d002f5c:	0f4007db 	jal	9d001f6c <nrf24l01_execute_command>
9d002f60:	24070001 	li	a3,1
}
9d002f64:	8fbf0014 	lw	ra,20(sp)
9d002f68:	03e00008 	jr	ra
9d002f6c:	27bd0018 	addiu	sp,sp,24

9d002f70 <nrf24l01_nop>:

//executes the FLUSH_TX SPI operation
//this funciton does nothing
//returns the value of the STATUS register
unsigned char nrf24l01_nop()
{
9d002f70:	27bdffe8 	addiu	sp,sp,-24
9d002f74:	afbf0014 	sw	ra,20(sp)
	return nrf24l01_execute_command(nrf24l01_NOP, NULL, 0, true);
9d002f78:	240400ff 	li	a0,255
9d002f7c:	00002821 	move	a1,zero
9d002f80:	00003021 	move	a2,zero
9d002f84:	0f4007db 	jal	9d001f6c <nrf24l01_execute_command>
9d002f88:	24070001 	li	a3,1
}
9d002f8c:	8fbf0014 	lw	ra,20(sp)
9d002f90:	03e00008 	jr	ra
9d002f94:	27bd0018 	addiu	sp,sp,24

9d002f98 <nrf24l01_get_status>:
	return data;
}

//return the value of the status register
unsigned char nrf24l01_get_status()
{
9d002f98:	27bdffe8 	addiu	sp,sp,-24
9d002f9c:	afbf0014 	sw	ra,20(sp)
	return nrf24l01_nop();
9d002fa0:	0f400bdc 	jal	9d002f70 <nrf24l01_nop>
9d002fa4:	00000000 	nop
}
9d002fa8:	8fbf0014 	lw	ra,20(sp)
9d002fac:	03e00008 	jr	ra
9d002fb0:	27bd0018 	addiu	sp,sp,24

9d002fb4 <nrf24l01_get_rx_pipe>:
	nrf24l01_write_register(nrf24l01_STATUS, &data, 1); 
}

//returns the current pipe in the 24L01's STATUS register
unsigned char nrf24l01_get_rx_pipe()
{
9d002fb4:	27bdffe8 	addiu	sp,sp,-24
9d002fb8:	afbf0014 	sw	ra,20(sp)
}

//return the value of the status register
unsigned char nrf24l01_get_status()
{
	return nrf24l01_nop();
9d002fbc:	0f400bdc 	jal	9d002f70 <nrf24l01_nop>
9d002fc0:	00000000 	nop

//returns the current pipe in the 24L01's STATUS register
unsigned char nrf24l01_get_rx_pipe()
{
	return nrf24l01_get_rx_pipe_from_status(nrf24l01_get_status());
}
9d002fc4:	7c421040 	ext	v0,v0,0x1,0x3
9d002fc8:	8fbf0014 	lw	ra,20(sp)
9d002fcc:	03e00008 	jr	ra
9d002fd0:	27bd0018 	addiu	sp,sp,24

9d002fd4 <nrf24l01_irq_max_rt_active>:
	return (nrf24l01_get_status() & nrf24l01_STATUS_TX_DS);
}

//returns true if MAX_RT interrupt is active, false otherwise
bool nrf24l01_irq_max_rt_active()
{
9d002fd4:	27bdffe8 	addiu	sp,sp,-24
9d002fd8:	afbf0014 	sw	ra,20(sp)
}

//return the value of the status register
unsigned char nrf24l01_get_status()
{
	return nrf24l01_nop();
9d002fdc:	0f400bdc 	jal	9d002f70 <nrf24l01_nop>
9d002fe0:	00000000 	nop

//returns true if MAX_RT interrupt is active, false otherwise
bool nrf24l01_irq_max_rt_active()
{
	return (nrf24l01_get_status() & nrf24l01_STATUS_MAX_RT);
}
9d002fe4:	30420010 	andi	v0,v0,0x10
9d002fe8:	8fbf0014 	lw	ra,20(sp)
9d002fec:	03e00008 	jr	ra
9d002ff0:	27bd0018 	addiu	sp,sp,24

9d002ff4 <nrf24l01_irq_tx_ds_active>:
	return (nrf24l01_get_status() & nrf24l01_STATUS_RX_DR);
}

//returns true if TX_DS interrupt is active, false otherwise
bool nrf24l01_irq_tx_ds_active()
{
9d002ff4:	27bdffe8 	addiu	sp,sp,-24
9d002ff8:	afbf0014 	sw	ra,20(sp)
}

//return the value of the status register
unsigned char nrf24l01_get_status()
{
	return nrf24l01_nop();
9d002ffc:	0f400bdc 	jal	9d002f70 <nrf24l01_nop>
9d003000:	00000000 	nop

//returns true if TX_DS interrupt is active, false otherwise
bool nrf24l01_irq_tx_ds_active()
{
	return (nrf24l01_get_status() & nrf24l01_STATUS_TX_DS);
}
9d003004:	30420020 	andi	v0,v0,0x20
9d003008:	8fbf0014 	lw	ra,20(sp)
9d00300c:	03e00008 	jr	ra
9d003010:	27bd0018 	addiu	sp,sp,24

9d003014 <nrf24l01_irq_rx_dr_active>:
		return true;
}

//returns true if RX_DR interrupt is active, false otherwise
bool nrf24l01_irq_rx_dr_active()
{
9d003014:	27bdffe8 	addiu	sp,sp,-24
9d003018:	afbf0014 	sw	ra,20(sp)
}

//return the value of the status register
unsigned char nrf24l01_get_status()
{
	return nrf24l01_nop();
9d00301c:	0f400bdc 	jal	9d002f70 <nrf24l01_nop>
9d003020:	00000000 	nop

//returns true if RX_DR interrupt is active, false otherwise
bool nrf24l01_irq_rx_dr_active()
{
	return (nrf24l01_get_status() & nrf24l01_STATUS_RX_DR);
}
9d003024:	30420040 	andi	v0,v0,0x40
9d003028:	8fbf0014 	lw	ra,20(sp)
9d00302c:	03e00008 	jr	ra
9d003030:	27bd0018 	addiu	sp,sp,24

9d003034 <NU32_Startup>:

// Perform startup routines:
//  Make NU32_LED1 and NU32_LED2 pins outputs (NU32_USER is by default an input)
//  Initialize the serial port - UART3 (no interrupt) 
//  Enable interrupts
void NU32_Startup() {
9d003034:	27bdfff8 	addiu	sp,sp,-8
9d003038:	afbf0004 	sw	ra,4(sp)
  // disable interrupts
  __builtin_disable_interrupts();
9d00303c:	41626000 	di	v0
9d003040:	000000c0 	ehb
  // see Chapter 2 "CPU for Devices with M4K Core" of the PIC32 reference manual
  // most of the other bits have prescribed values
  // microchip does not provide a _CP0_SET_CONFIG macro, so we directly use
  // the compiler built-in command _mtc0
  // to disable cache, use 0xa4210582 
  __builtin_mtc0(_CP0_CONFIG, _CP0_CONFIG_SELECT, 0xa4210583); 
9d003044:	3c02a421 	lui	v0,0xa421
9d003048:	24420583 	addiu	v0,v0,1411
9d00304c:	40828000 	mtc0	v0,c0_config
9d003050:	000000c0 	ehb
  
  // set the prefectch cache wait state to 2, as per the
  // electrical characteristics data sheet
  CHECONbits.PFMWS = 0x2;   
9d003054:	3c02bf88 	lui	v0,0xbf88
9d003058:	8c434000 	lw	v1,16384(v0)
9d00305c:	24050002 	li	a1,2
9d003060:	7ca31004 	ins	v1,a1,0x0,0x3
9d003064:	ac434000 	sw	v1,16384(v0)

  //enable prefetch for cacheable and noncacheable memory
  CHECONbits.PREFEN = 0x3; 
9d003068:	8c434000 	lw	v1,16384(v0)
9d00306c:	24040003 	li	a0,3
9d003070:	7c832904 	ins	v1,a0,0x4,0x2
9d003074:	ac434000 	sw	v1,16384(v0)

  // 0 data RAM access wait states
  BMXCONbits.BMXWSDRM = 0x0;
9d003078:	3c02bf88 	lui	v0,0xbf88
9d00307c:	8c432000 	lw	v1,8192(v0)
9d003080:	7c033184 	ins	v1,zero,0x6,0x1
9d003084:	ac432000 	sw	v1,8192(v0)
  
  // enable multi vector interrupts
  INTCONbits.MVEC = 0x1;
9d003088:	3c02bf88 	lui	v0,0xbf88
9d00308c:	8c461000 	lw	a2,4096(v0)
9d003090:	24030001 	li	v1,1
9d003094:	7c666304 	ins	a2,v1,0xc,0x1
9d003098:	ac461000 	sw	a2,4096(v0)

  // disable JTAG to get B10, B11, B12 and B13 back
  DDPCONbits.JTAGEN = 0;
9d00309c:	3c02bf81 	lui	v0,0xbf81
9d0030a0:	9046f200 	lbu	a2,-3584(v0)
9d0030a4:	7c0618c4 	ins	a2,zero,0x3,0x1
9d0030a8:	a046f200 	sb	a2,-3584(v0)

  TRISFCLR = 0x0003;  // Make F0 and F1 outputs (LED1 and LED2)
9d0030ac:	3c02bf88 	lui	v0,0xbf88
9d0030b0:	ac446144 	sw	a0,24900(v0)
  NU32_LED1 = 1;      // LED1 is off
9d0030b4:	3c02bf88 	lui	v0,0xbf88
9d0030b8:	90446160 	lbu	a0,24928(v0)
9d0030bc:	7c640004 	ins	a0,v1,0x0,0x1
9d0030c0:	a0446160 	sb	a0,24928(v0)
  NU32_LED2 = 0;      // LED2 is on
9d0030c4:	90446160 	lbu	a0,24928(v0)
9d0030c8:	7c040844 	ins	a0,zero,0x1,0x1
9d0030cc:	a0446160 	sb	a0,24928(v0)

  // turn on UART3 without an interrupt
  U3MODEbits.BRGH = 0; // set baud to NU32_DESIRED_BAUD
9d0030d0:	3c02bf80 	lui	v0,0xbf80
9d0030d4:	94446400 	lhu	a0,25600(v0)
9d0030d8:	7c0418c4 	ins	a0,zero,0x3,0x1
9d0030dc:	a4446400 	sh	a0,25600(v0)
  U3BRG = ((NU32_SYS_FREQ / NU32_DESIRED_BAUD) / 16) - 1;
9d0030e0:	24060014 	li	a2,20
9d0030e4:	3c04bf80 	lui	a0,0xbf80
9d0030e8:	ac866440 	sw	a2,25664(a0)

  // 8 bit, no parity bit, and 1 stop bit (8N1 setup)
  U3MODEbits.PDSEL = 0;
9d0030ec:	94446400 	lhu	a0,25600(v0)
9d0030f0:	7c041044 	ins	a0,zero,0x1,0x2
9d0030f4:	a4446400 	sh	a0,25600(v0)
  U3MODEbits.STSEL = 0;
9d0030f8:	94446400 	lhu	a0,25600(v0)
9d0030fc:	7c040004 	ins	a0,zero,0x0,0x1
9d003100:	a4446400 	sh	a0,25600(v0)

  // configure TX & RX pins as output & input pins
  U3STAbits.UTXEN = 1;
9d003104:	3c04bf80 	lui	a0,0xbf80
9d003108:	8c866410 	lw	a2,25616(a0)
9d00310c:	7c665284 	ins	a2,v1,0xa,0x1
9d003110:	ac866410 	sw	a2,25616(a0)
  U3STAbits.URXEN = 1;
9d003114:	8c866410 	lw	a2,25616(a0)
9d003118:	7c666304 	ins	a2,v1,0xc,0x1
9d00311c:	ac866410 	sw	a2,25616(a0)
  // configure hardware flow control using RTS and CTS
  U3MODEbits.UEN = 2;
9d003120:	94446400 	lhu	a0,25600(v0)
9d003124:	7ca44a04 	ins	a0,a1,0x8,0x2
9d003128:	a4446400 	sh	a0,25600(v0)

  // enable the uart
  U3MODEbits.ON = 1;
9d00312c:	94446400 	lhu	a0,25600(v0)
9d003130:	7c647bc4 	ins	a0,v1,0xf,0x1
9d003134:	a4446400 	sh	a0,25600(v0)

  __builtin_enable_interrupts();
9d003138:	41626020 	ei	v0
}
9d00313c:	8fbf0004 	lw	ra,4(sp)
9d003140:	03e00008 	jr	ra
9d003144:	27bd0008 	addiu	sp,sp,8

9d003148 <NU32_ReadUART3>:
// Read from UART3
// block other functions until you get a '\r' or '\n'
// send the pointer to your char array and the number of elements in the array
void NU32_ReadUART3(char * message, int maxLength) {
  char data = 0;
  int complete = 0, num_bytes = 0;
9d003148:	00003021 	move	a2,zero
  // loop until you get a '\r' or '\n'
  while (!complete) {
    if (U3STAbits.URXDA) { // if data is available
9d00314c:	3c03bf80 	lui	v1,0xbf80
      data = U3RXREG;      // read the data
9d003150:	3c08bf80 	lui	t0,0xbf80
      if ((data == '\n') || (data == '\r')) {
9d003154:	2407000a 	li	a3,10
9d003158:	0b400c66 	j	9d003198 <NU32_ReadUART3+0x50>
9d00315c:	2409000d 	li	t1,13
void NU32_ReadUART3(char * message, int maxLength) {
  char data = 0;
  int complete = 0, num_bytes = 0;
  // loop until you get a '\r' or '\n'
  while (!complete) {
    if (U3STAbits.URXDA) { // if data is available
9d003160:	8c626410 	lw	v0,25616(v1)
9d003164:	30420001 	andi	v0,v0,0x1
9d003168:	1040fffd 	beqz	v0,9d003160 <NU32_ReadUART3+0x18>
9d00316c:	00000000 	nop
      data = U3RXREG;      // read the data
9d003170:	8d026430 	lw	v0,25648(t0)
9d003174:	7c021420 	seb	v0,v0
      if ((data == '\n') || (data == '\r')) {
9d003178:	5047000e 	beql	v0,a3,9d0031b4 <NU32_ReadUART3+0x6c>
9d00317c:	00862021 	addu	a0,a0,a2
9d003180:	1049000b 	beq	v0,t1,9d0031b0 <NU32_ReadUART3+0x68>
9d003184:	00865021 	addu	t2,a0,a2
        complete = 1;
      } else {
        message[num_bytes] = data;
9d003188:	a1420000 	sb	v0,0(t2)
        ++num_bytes;
9d00318c:	24c60001 	addiu	a2,a2,1
        // roll over if the array is too small
        if (num_bytes >= maxLength) {
9d003190:	00c5102a 	slt	v0,a2,a1
          num_bytes = 0;
9d003194:	0002300a 	movz	a2,zero,v0
void NU32_ReadUART3(char * message, int maxLength) {
  char data = 0;
  int complete = 0, num_bytes = 0;
  // loop until you get a '\r' or '\n'
  while (!complete) {
    if (U3STAbits.URXDA) { // if data is available
9d003198:	8c626410 	lw	v0,25616(v1)
9d00319c:	30420001 	andi	v0,v0,0x1
9d0031a0:	1040ffef 	beqz	v0,9d003160 <NU32_ReadUART3+0x18>
9d0031a4:	00000000 	nop
9d0031a8:	0b400c5c 	j	9d003170 <NU32_ReadUART3+0x28>
9d0031ac:	00000000 	nop
        }
      }
    }
  }
  // end the string
  message[num_bytes] = '\0';
9d0031b0:	00862021 	addu	a0,a0,a2
9d0031b4:	03e00008 	jr	ra
9d0031b8:	a0800000 	sb	zero,0(a0)

9d0031bc <NU32_WriteUART3>:
}

// Write a character array using UART3
void NU32_WriteUART3(const char * string) {
  while (*string != '\0') {
9d0031bc:	80850000 	lb	a1,0(a0)
9d0031c0:	10a0000b 	beqz	a1,9d0031f0 <NU32_WriteUART3+0x34>
9d0031c4:	3c03bf80 	lui	v1,0xbf80
    while (U3STAbits.UTXBF) {
      ; // wait until tx buffer isn't full
    }
    U3TXREG = *string;
9d0031c8:	3c06bf80 	lui	a2,0xbf80
}

// Write a character array using UART3
void NU32_WriteUART3(const char * string) {
  while (*string != '\0') {
    while (U3STAbits.UTXBF) {
9d0031cc:	8c626410 	lw	v0,25616(v1)
9d0031d0:	30420200 	andi	v0,v0,0x200
9d0031d4:	1440fffd 	bnez	v0,9d0031cc <NU32_WriteUART3+0x10>
9d0031d8:	00000000 	nop
      ; // wait until tx buffer isn't full
    }
    U3TXREG = *string;
9d0031dc:	acc56420 	sw	a1,25632(a2)
    ++string;
9d0031e0:	24840001 	addiu	a0,a0,1
  message[num_bytes] = '\0';
}

// Write a character array using UART3
void NU32_WriteUART3(const char * string) {
  while (*string != '\0') {
9d0031e4:	80850000 	lb	a1,0(a0)
9d0031e8:	14a0fff8 	bnez	a1,9d0031cc <NU32_WriteUART3+0x10>
9d0031ec:	00000000 	nop
9d0031f0:	03e00008 	jr	ra
9d0031f4:	00000000 	nop

9d0031f8 <NU32_ReadCharUART3>:
// read just one character at a time
char NU32_ReadCharUART3(void) {
  char data;
  char complete = 0;
  while(complete == 0){
    if (U3STAbits.URXDA) { // if data is available
9d0031f8:	3c02bf80 	lui	v0,0xbf80
9d0031fc:	8c426410 	lw	v0,25616(v0)
9d003200:	30420001 	andi	v0,v0,0x1
9d003204:	14400006 	bnez	v0,9d003220 <NU32_ReadCharUART3+0x28>
9d003208:	3c02bf80 	lui	v0,0xbf80
9d00320c:	3c03bf80 	lui	v1,0xbf80
9d003210:	8c626410 	lw	v0,25616(v1)
9d003214:	30420001 	andi	v0,v0,0x1
9d003218:	1040fffd 	beqz	v0,9d003210 <NU32_ReadCharUART3+0x18>
9d00321c:	3c02bf80 	lui	v0,0xbf80
      data = U3RXREG;      // read the data
9d003220:	8c426430 	lw	v0,25648(v0)
      complete = 1;
    }
  }
  return data;
}
9d003224:	03e00008 	jr	ra
9d003228:	7c021420 	seb	v0,v0

9d00322c <NU32_WriteCharUART3>:

// // Write a character array using UART3
void NU32_WriteCharUART3(char data) {
    while (U3STAbits.UTXBF) {
9d00322c:	3c03bf80 	lui	v1,0xbf80
9d003230:	8c626410 	lw	v0,25616(v1)
9d003234:	30420200 	andi	v0,v0,0x200
9d003238:	1440fffd 	bnez	v0,9d003230 <NU32_WriteCharUART3+0x4>
9d00323c:	3c02bf80 	lui	v0,0xbf80
      ; // wait until tx buffer isn't full
    }
    U3TXREG = data;
9d003240:	ac446420 	sw	a0,25632(v0)
9d003244:	03e00008 	jr	ra
9d003248:	00000000 	nop

Disassembly of section .text:

9d00324c <InitializeIO>:
   } 
}

void InitializeIO(void)
{
	AD1CON1 = 0x00; //disable AD converter functionality on PORTE
9d00324c:	3c02bf81 	lui	v0,0xbf81
9d003250:	ac409000 	sw	zero,-28672(v0)
	TRISEbits.TRISE0 = 0; //make PORTA.0 an output to control LED
9d003254:	3c02bf88 	lui	v0,0xbf88
9d003258:	90436100 	lbu	v1,24832(v0)
9d00325c:	7c030004 	ins	v1,zero,0x0,0x1
9d003260:	a0436100 	sb	v1,24832(v0)
	PORTEbits.RE0 = 1; //turn on LED
9d003264:	3c02bf88 	lui	v0,0xbf88
9d003268:	90436110 	lbu	v1,24848(v0)
9d00326c:	24040001 	li	a0,1
9d003270:	7c830004 	ins	v1,a0,0x0,0x1
9d003274:	a0436110 	sb	v1,24848(v0)
	
	TRISBbits.TRISB1 = 1; //make sure that PORTB.1 is input since it is IRQ pin
9d003278:	3c02bf88 	lui	v0,0xbf88
9d00327c:	94436040 	lhu	v1,24640(v0)
9d003280:	7c830844 	ins	v1,a0,0x1,0x1
9d003284:	a4436040 	sh	v1,24640(v0)
9d003288:	03e00008 	jr	ra
9d00328c:	00000000 	nop

9d003290 <ToggleLED>:
}

//toggles on-board LED
void ToggleLED(void)
{
	PORTEbits.RE0 = ~PORTEbits.RE0; //invert the bit that controls the LED
9d003290:	3c02bf88 	lui	v0,0xbf88
9d003294:	8c446110 	lw	a0,24848(v0)
9d003298:	30840001 	andi	a0,a0,0x1
9d00329c:	38840001 	xori	a0,a0,0x1
9d0032a0:	90436110 	lbu	v1,24848(v0)
9d0032a4:	7c830004 	ins	v1,a0,0x0,0x1
9d0032a8:	a0436110 	sb	v1,24848(v0)
9d0032ac:	03e00008 	jr	ra
9d0032b0:	00000000 	nop

9d0032b4 <main>:
// SCK4 -> SCK3 (pin B14 -> pin D1)
void InitializeIO(void);
//void checkForUARTData(void);
void ToggleLED(void);

int main(void){
9d0032b4:	27bdffd8 	addiu	sp,sp,-40
9d0032b8:	afbf0024 	sw	ra,36(sp)
9d0032bc:	afb10020 	sw	s1,32(sp)
	unsigned char data;// byte of data sent/received
	unsigned char dataArray;// UART read needs array
	unsigned int count;// counter for for loop

	// Configuure the PIC 32 and initialize the NRF
	NU32_Startup();// setup UART
9d0032c0:	0f400c0d 	jal	9d003034 <NU32_Startup>
9d0032c4:	afb0001c 	sw	s0,28(sp)

9d0032c8 <.LVL0>:
	setup_spi4();// setup SPI4 as master
9d0032c8:	0f400d22 	jal	9d003488 <setup_spi4>
9d0032cc:	3c119d00 	lui	s1,0x9d00

9d0032d0 <.LVL1>:
	InitializeIO();// setup GPIO pins
9d0032d0:	0f400c93 	jal	9d00324c <InitializeIO>
9d0032d4:	26313724 	addiu	s1,s1,14116

9d0032d8 <.LVL2>:
	nrf24l01_initialize_debug(false, 1, false); //initialize the 24L01 to the debug configuration as TX, 1 data byte, and auto-ack disabled
9d0032d8:	00002021 	move	a0,zero
9d0032dc:	24050001 	li	a1,1
9d0032e0:	0f400982 	jal	9d002608 <nrf24l01_initialize_debug>
9d0032e4:	00003021 	move	a2,zero

9d0032e8 <.LVL3>:
	
	NU32_WriteUART3("Running...\r\n");  
9d0032e8:	3c049d00 	lui	a0,0x9d00
9d0032ec:	0f400c6f 	jal	9d0031bc <NU32_WriteUART3>
9d0032f0:	24843714 	addiu	a0,a0,14100

9d0032f4 <.LVL4>:
    nrf24l01_irq_clear_all(); //clear interrupts again 
    nrf24l01_set_as_rx(true); //resume normal operation as an RX 

    NU32_WriteUART3("Receiver received: ");
	NU32_WriteUART3(&data);
	NU32_WriteUART3("\n");
9d0032f4:	3c109d00 	lui	s0,0x9d00
9d0032f8:	26103738 	addiu	s0,s0,14136
	NU32_WriteUART3("Running...\r\n");  
	//main program loop 
   while(1) 
   { 
    //wait until a packet has been received 
    while(!(nrf24l01_irq_pin_active() && nrf24l01_irq_rx_dr_active())); 
9d0032fc:	0f4007b9 	jal	9d001ee4 <nrf24l01_irq_pin_active>
9d003300:	00000000 	nop

9d003304 <.LVL5>:
9d003304:	1040fffd 	beqz	v0,9d0032fc <.LVL4+0x8>
9d003308:	00000000 	nop
9d00330c:	0f400c05 	jal	9d003014 <nrf24l01_irq_rx_dr_active>
9d003310:	00000000 	nop

9d003314 <.LVL6>:
9d003314:	1040fff9 	beqz	v0,9d0032fc <.LVL4+0x8>
9d003318:	27a40010 	addiu	a0,sp,16
       
    nrf24l01_read_rx_payload(&data, 1); //read the packet into data 
9d00331c:	0f400b9f 	jal	9d002e7c <nrf24l01_read_rx_payload>
9d003320:	24050001 	li	a1,1

9d003324 <.LVL7>:
    nrf24l01_irq_clear_all(); //clear all interrupts in the 24L01 
9d003324:	0f4008a8 	jal	9d0022a0 <nrf24l01_irq_clear_all>
9d003328:	00000000 	nop

9d00332c <.LVL8>:
       
    DelayUS(130); //wait for the other 24L01 to come from standby to RX 
9d00332c:	0f400d51 	jal	9d003544 <DelayUS>
9d003330:	24040082 	li	a0,130

9d003334 <.LVL9>:
       
    nrf24l01_set_as_tx(); //change the device to a TX to send back from the other 24L01 
9d003334:	0f400a0c 	jal	9d002830 <nrf24l01_set_as_tx>
9d003338:	00000000 	nop

9d00333c <.LVL10>:
    nrf24l01_write_tx_payload(&data, 1, true); //transmit received char over RF 
9d00333c:	27a40010 	addiu	a0,sp,16
9d003340:	24050001 	li	a1,1
9d003344:	0f400b87 	jal	9d002e1c <nrf24l01_write_tx_payload>
9d003348:	24060001 	li	a2,1

9d00334c <.LVL11>:
       
    //wait until the packet has been sent 
    while(!(nrf24l01_irq_pin_active() && nrf24l01_irq_tx_ds_active())); 
9d00334c:	0f4007b9 	jal	9d001ee4 <nrf24l01_irq_pin_active>
9d003350:	00000000 	nop

9d003354 <.LVL12>:
9d003354:	1040fffd 	beqz	v0,9d00334c <.LVL11>
9d003358:	00000000 	nop
9d00335c:	0f400bfd 	jal	9d002ff4 <nrf24l01_irq_tx_ds_active>
9d003360:	00000000 	nop

9d003364 <.LVL13>:
9d003364:	1040fff9 	beqz	v0,9d00334c <.LVL11>
9d003368:	00000000 	nop

    nrf24l01_irq_clear_all(); //clear interrupts again 
9d00336c:	0f4008a8 	jal	9d0022a0 <nrf24l01_irq_clear_all>
9d003370:	00000000 	nop

9d003374 <.LVL14>:
    nrf24l01_set_as_rx(true); //resume normal operation as an RX 
9d003374:	0f4009ee 	jal	9d0027b8 <nrf24l01_set_as_rx>
9d003378:	24040001 	li	a0,1

9d00337c <.LVL15>:

    NU32_WriteUART3("Receiver received: ");
9d00337c:	0f400c6f 	jal	9d0031bc <NU32_WriteUART3>
9d003380:	02202021 	move	a0,s1

9d003384 <.LVL16>:
	NU32_WriteUART3(&data);
9d003384:	0f400c6f 	jal	9d0031bc <NU32_WriteUART3>
9d003388:	27a40010 	addiu	a0,sp,16

9d00338c <.LVL17>:
	NU32_WriteUART3("\n");
9d00338c:	0f400c6f 	jal	9d0031bc <NU32_WriteUART3>
9d003390:	02002021 	move	a0,s0

9d003394 <.LVL18>:
	DelayUS(130); //wait for receiver to come from standby to RX
9d003394:	0f400d51 	jal	9d003544 <DelayUS>
9d003398:	24040082 	li	a0,130

9d00339c <.LVL19>:

    ToggleLED(); //toggle the on-board LED as visual indication that the loop has completed 
9d00339c:	0f400ca4 	jal	9d003290 <ToggleLED>
9d0033a0:	00000000 	nop

9d0033a4 <.LVL20>:
   } 
9d0033a4:	0b400cbf 	j	9d0032fc <.LVL4+0x8>
9d0033a8:	00000000 	nop

Disassembly of section .text.general_exception:

9d0033ac <_general_exception_context>:
9d0033ac:	27bdffa8 	addiu	sp,sp,-88
9d0033b0:	afa10004 	sw	at,4(sp)
9d0033b4:	afa20008 	sw	v0,8(sp)
9d0033b8:	afa3000c 	sw	v1,12(sp)
9d0033bc:	afa40010 	sw	a0,16(sp)
9d0033c0:	afa50014 	sw	a1,20(sp)
9d0033c4:	afa60018 	sw	a2,24(sp)
9d0033c8:	afa7001c 	sw	a3,28(sp)
9d0033cc:	afa80020 	sw	t0,32(sp)
9d0033d0:	afa90024 	sw	t1,36(sp)
9d0033d4:	afaa0028 	sw	t2,40(sp)
9d0033d8:	afab002c 	sw	t3,44(sp)
9d0033dc:	afac0030 	sw	t4,48(sp)
9d0033e0:	afad0034 	sw	t5,52(sp)
9d0033e4:	afae0038 	sw	t6,56(sp)
9d0033e8:	afaf003c 	sw	t7,60(sp)
9d0033ec:	afb80040 	sw	t8,64(sp)
9d0033f0:	afb90044 	sw	t9,68(sp)
9d0033f4:	afbf0048 	sw	ra,72(sp)
9d0033f8:	00004012 	mflo	t0
9d0033fc:	afa8004c 	sw	t0,76(sp)
9d003400:	00004010 	mfhi	t0
9d003404:	afa80050 	sw	t0,80(sp)
9d003408:	3c1a9d00 	lui	k0,0x9d00
9d00340c:	275a3640 	addiu	k0,k0,13888
9d003410:	00000000 	nop
9d003414:	40046800 	mfc0	a0,c0_cause
9d003418:	40056000 	mfc0	a1,c0_status
9d00341c:	0340f809 	jalr	k0
9d003420:	00000000 	nop
9d003424:	8fa80050 	lw	t0,80(sp)
9d003428:	01000011 	mthi	t0
9d00342c:	8fa8004c 	lw	t0,76(sp)
9d003430:	01000013 	mtlo	t0
9d003434:	8fa10004 	lw	at,4(sp)
9d003438:	8fa20008 	lw	v0,8(sp)
9d00343c:	8fa3000c 	lw	v1,12(sp)
9d003440:	8fa40010 	lw	a0,16(sp)
9d003444:	8fa50014 	lw	a1,20(sp)
9d003448:	8fa60018 	lw	a2,24(sp)
9d00344c:	8fa7001c 	lw	a3,28(sp)
9d003450:	8fa80020 	lw	t0,32(sp)
9d003454:	8fa90024 	lw	t1,36(sp)
9d003458:	8faa0028 	lw	t2,40(sp)
9d00345c:	8fab002c 	lw	t3,44(sp)
9d003460:	8fac0030 	lw	t4,48(sp)
9d003464:	8fad0034 	lw	t5,52(sp)
9d003468:	8fae0038 	lw	t6,56(sp)
9d00346c:	8faf003c 	lw	t7,60(sp)
9d003470:	8fb80040 	lw	t8,64(sp)
9d003474:	8fb90044 	lw	t9,68(sp)
9d003478:	8fbf0048 	lw	ra,72(sp)
9d00347c:	27bd0058 	addiu	sp,sp,88
9d003480:	000000c0 	ehb
9d003484:	42000018 	eret

Disassembly of section .text:

9d003488 <setup_spi4>:
#include "NU32.h"
void setup_spi4(void){

	// Master - SPI4 pins are: SDI4(F4), SDO4(F5), SCK4(B14), SS4(B8; not connected)
	// since the PIC is just starting, we know that SPI is off. We rely on defaults here
	SPI4BUF;// clear the RX buffer by reading from it
9d003488:	3c02bf80 	lui	v0,0xbf80
9d00348c:	8c425c20 	lw	v0,23584(v0)
	SPI4BRG = 0x4;// baud rate to 8 MHz [SPI4BRG = (8000000/(2*desired)) - 1]
9d003490:	24030004 	li	v1,4
9d003494:	3c02bf80 	lui	v0,0xbf80
9d003498:	ac435c30 	sw	v1,23600(v0)
	SPI4STATbits.SPIROV = 0;// clear the overflow bit
9d00349c:	3c02bf80 	lui	v0,0xbf80
9d0034a0:	8c435c10 	lw	v1,23568(v0)
9d0034a4:	7c033184 	ins	v1,zero,0x6,0x1
9d0034a8:	ac435c10 	sw	v1,23568(v0)
	SPI4CONbits.MODE32 = 0;// use 8 bit mode
9d0034ac:	3c02bf80 	lui	v0,0xbf80
9d0034b0:	8c435c00 	lw	v1,23552(v0)
9d0034b4:	7c035ac4 	ins	v1,zero,0xb,0x1
9d0034b8:	ac435c00 	sw	v1,23552(v0)
	SPI4CONbits.MODE16 = 0;
9d0034bc:	8c435c00 	lw	v1,23552(v0)
9d0034c0:	7c035284 	ins	v1,zero,0xa,0x1
9d0034c4:	ac435c00 	sw	v1,23552(v0)
	SPI4CONbits.MSTEN = 1;// master operation
9d0034c8:	8c435c00 	lw	v1,23552(v0)
9d0034cc:	24040001 	li	a0,1
9d0034d0:	7c832944 	ins	v1,a0,0x5,0x1
9d0034d4:	ac435c00 	sw	v1,23552(v0)
	SPI4CONbits.ON = 1;// turn on spi 4
9d0034d8:	8c435c00 	lw	v1,23552(v0)
9d0034dc:	7c837bc4 	ins	v1,a0,0xf,0x1
9d0034e0:	ac435c00 	sw	v1,23552(v0)
9d0034e4:	03e00008 	jr	ra
9d0034e8:	00000000 	nop

9d0034ec <spi4_write>:

}
void spi4_write(unsigned char byte){
	SPI4BUF = byte;// write single byte to SPI4
9d0034ec:	3c02bf80 	lui	v0,0xbf80
9d0034f0:	ac445c20 	sw	a0,23584(v0)
9d0034f4:	03e00008 	jr	ra
9d0034f8:	00000000 	nop

9d0034fc <spi4_read>:
}
unsigned char spi4_read(void){
	while(!SPI4STATbits.SPIRBF){
9d0034fc:	3c03bf80 	lui	v1,0xbf80
9d003500:	8c625c10 	lw	v0,23568(v1)
9d003504:	30420001 	andi	v0,v0,0x1
9d003508:	1040fffd 	beqz	v0,9d003500 <spi4_read+0x4>
9d00350c:	3c02bf80 	lui	v0,0xbf80
			;// wait until data is ready
		}
	return SPI4BUF;// return the byte
9d003510:	8c425c20 	lw	v0,23584(v0)
}
9d003514:	03e00008 	jr	ra
9d003518:	304200ff 	andi	v0,v0,0xff

9d00351c <spi4_send_read_byte>:
unsigned char spi4_send_read_byte(unsigned char byte){
	SPI4BUF = byte;// write single byte
9d00351c:	3c02bf80 	lui	v0,0xbf80
9d003520:	ac445c20 	sw	a0,23584(v0)
	while(!SPI4STATbits.SPIRBF){
9d003524:	3c03bf80 	lui	v1,0xbf80
9d003528:	8c625c10 	lw	v0,23568(v1)
9d00352c:	30420001 	andi	v0,v0,0x1
9d003530:	1040fffd 	beqz	v0,9d003528 <spi4_send_read_byte+0xc>
9d003534:	3c02bf80 	lui	v0,0xbf80
		;// wait until data is ready
	}
	return SPI4BUF;//SPI4BUF;// return the byte
9d003538:	8c425c20 	lw	v0,23584(v0)
}
9d00353c:	03e00008 	jr	ra
9d003540:	304200ff 	andi	v0,v0,0xff

9d003544 <DelayUS>:
#include "delays.h"

void DelayUS(unsigned long microseconds)
{
  int j;
  for (j = 0; j < 40*microseconds; j++) { // number is 1 million
9d003544:	000418c0 	sll	v1,a0,0x3
9d003548:	00042140 	sll	a0,a0,0x5
9d00354c:	00641821 	addu	v1,v1,a0
9d003550:	10600004 	beqz	v1,9d003564 <DelayUS+0x20>
9d003554:	00001021 	move	v0,zero
9d003558:	24420001 	addiu	v0,v0,1
9d00355c:	1443ffff 	bne	v0,v1,9d00355c <DelayUS+0x18>
9d003560:	24420001 	addiu	v0,v0,1
9d003564:	03e00008 	jr	ra
9d003568:	00000000 	nop

9d00356c <DelayMS>:

void DelayMS(unsigned long milliseconds)
{
	unsigned long count;
	
	for(count = 0; count < milliseconds; count++)
9d00356c:	10800004 	beqz	a0,9d003580 <DelayMS+0x14>
9d003570:	00001021 	move	v0,zero
9d003574:	24420001 	addiu	v0,v0,1
9d003578:	1444ffff 	bne	v0,a0,9d003578 <DelayMS+0xc>
9d00357c:	24420001 	addiu	v0,v0,1
9d003580:	03e00008 	jr	ra
9d003584:	00000000 	nop

9d003588 <DelayS>:

void DelayS(unsigned long seconds)
{
	unsigned long count;
	
	for(count = 0; count < seconds; count++)
9d003588:	10800004 	beqz	a0,9d00359c <DelayS+0x14>
9d00358c:	00001021 	move	v0,zero
9d003590:	24420001 	addiu	v0,v0,1
9d003594:	1444ffff 	bne	v0,a0,9d003594 <DelayS+0xc>
9d003598:	24420001 	addiu	v0,v0,1
9d00359c:	03e00008 	jr	ra
9d0035a0:	00000000 	nop

Disassembly of section .text.main_entry:

9d0035a4 <_main_entry>:
9d0035a4:	3c040000 	lui	a0,0x0
9d0035a8:	27bdffe8 	addiu	sp,sp,-24
9d0035ac:	24840000 	addiu	a0,a0,0
9d0035b0:	10800003 	beqz	a0,9d0035c0 <_main_entry+0x1c>
9d0035b4:	afbf0014 	sw	ra,20(sp)
9d0035b8:	0080f809 	jalr	a0
9d0035bc:	00000000 	nop
9d0035c0:	30840000 	andi	a0,a0,0x0
9d0035c4:	30a50000 	andi	a1,a1,0x0
9d0035c8:	3c089d00 	lui	t0,0x9d00
9d0035cc:	250832b4 	addiu	t0,t0,12980
9d0035d0:	0100f809 	jalr	t0
9d0035d4:	00000000 	nop

9d0035d8 <__crt0_exit>:
9d0035d8:	3c020000 24420000 10400003 00000000     ...<..B$..@.....
9d0035e8:	0040f809 00000000 1000fff9 00000000     ..@.............

Disassembly of section .text._bootstrap_exception_handler:

9d0035f8 <_bootstrap_exception_handler>:
9d0035f8:	3c020000 	lui	v0,0x0
9d0035fc:	24420000 	addiu	v0,v0,0
9d003600:	10400005 	beqz	v0,9d003618 <_bootstrap_exception_handler+0x20>
9d003604:	3c020000 	lui	v0,0x0
9d003608:	24420000 	addiu	v0,v0,0
9d00360c:	10400003 	beqz	v0,9d00361c <_bootstrap_exception_handler+0x24>
9d003610:	3c029d00 	lui	v0,0x9d00
9d003614:	7000003f 	sdbbp
9d003618:	3c029d00 	lui	v0,0x9d00
9d00361c:	244236d0 	addiu	v0,v0,14032
9d003620:	10400005 	beqz	v0,9d003638 <.LCFI2>
9d003624:	00000000 	nop
9d003628:	27bdffe8 	addiu	sp,sp,-24

9d00362c <.LCFI0>:
9d00362c:	afbf0014 	sw	ra,20(sp)
9d003630:	0040f809 	jalr	v0
9d003634:	00000000 	nop

9d003638 <.LCFI2>:
9d003638:	0b400d8e 	j	9d003638 <.LCFI2>
9d00363c:	00000000 	nop

Disassembly of section .text._general_exception_handler:

9d003640 <_general_exception_handler>:
9d003640:	3c020000 	lui	v0,0x0
9d003644:	24420000 	addiu	v0,v0,0
9d003648:	10400005 	beqz	v0,9d003660 <_general_exception_handler+0x20>
9d00364c:	3c020000 	lui	v0,0x0
9d003650:	24420000 	addiu	v0,v0,0
9d003654:	10400003 	beqz	v0,9d003664 <_general_exception_handler+0x24>
9d003658:	3c029d00 	lui	v0,0x9d00
9d00365c:	7000003f 	sdbbp
9d003660:	3c029d00 	lui	v0,0x9d00
9d003664:	244236d0 	addiu	v0,v0,14032
9d003668:	10400005 	beqz	v0,9d003680 <.LCFI2>
9d00366c:	00000000 	nop
9d003670:	27bdffe8 	addiu	sp,sp,-24

9d003674 <.LCFI0>:
9d003674:	afbf0014 	sw	ra,20(sp)
9d003678:	0040f809 	jalr	v0
9d00367c:	00000000 	nop

9d003680 <.LCFI2>:
9d003680:	0b400da0 	j	9d003680 <.LCFI2>
9d003684:	00000000 	nop

Disassembly of section .vector_default:

9d003688 <_DefaultInterrupt>:
9d003688:	3c020000 	lui	v0,0x0
9d00368c:	24420000 	addiu	v0,v0,0
9d003690:	10400007 	beqz	v0,9d0036b0 <_DefaultInterrupt+0x28>
9d003694:	3c020000 	lui	v0,0x0
9d003698:	24420000 	addiu	v0,v0,0
9d00369c:	50400005 	beqzl	v0,9d0036b4 <_DefaultInterrupt+0x2c>
9d0036a0:	3c029d00 	lui	v0,0x9d00
9d0036a4:	7000003f 	sdbbp
9d0036a8:	03e00008 	jr	ra
9d0036ac:	00000000 	nop
9d0036b0:	3c029d00 	lui	v0,0x9d00
9d0036b4:	244236d0 	addiu	v0,v0,14032
9d0036b8:	10400003 	beqz	v0,9d0036c8 <_DefaultInterrupt+0x40>
9d0036bc:	00000000 	nop
9d0036c0:	0040f809 	jalr	v0
9d0036c4:	00000000 	nop
9d0036c8:	03e00008 	jr	ra
9d0036cc:	00000000 	nop

Disassembly of section .text:

9d0036d0 <__pic32_software_reset>:
9d0036d0:	41606000 	di
9d0036d4:	000000c0 	ehb
9d0036d8:	3c03aa99 	lui	v1,0xaa99
9d0036dc:	3c02bf81 	lui	v0,0xbf81
9d0036e0:	24636655 	addiu	v1,v1,26197
9d0036e4:	ac40f230 	sw	zero,-3536(v0)
9d0036e8:	ac43f230 	sw	v1,-3536(v0)
9d0036ec:	3c035566 	lui	v1,0x5566
9d0036f0:	346399aa 	ori	v1,v1,0x99aa
9d0036f4:	ac43f230 	sw	v1,-3536(v0)
9d0036f8:	3c02bf81 	lui	v0,0xbf81
9d0036fc:	24030001 	li	v1,1
9d003700:	ac43f618 	sw	v1,-2536(v0)
9d003704:	3c02bf81 	lui	v0,0xbf81
9d003708:	8c42f610 	lw	v0,-2544(v0)
9d00370c:	0b400db6 	j	9d0036d8 <__pic32_software_reset+0x8>
9d003710:	00000000 	nop

Disassembly of section .rodata:

9d003714 <.LC0>:
9d003714:	6e6e7552 	0x6e6e7552
9d003718:	2e676e69 	sltiu	a3,s3,28265
9d00371c:	0a0d2e2e 	j	9834b8b8 <_bmxdudba_address+0x9832b8b8>
9d003720:	00000000 	nop
9d003724:	65636552 	0x65636552
9d003728:	72657669 	0x72657669
9d00372c:	63657220 	0x63657220
9d003730:	65766965 	0x65766965
9d003734:	00203a64 	0x203a64
9d003738:	0000000a 	movz	zero,zero,zero

Disassembly of section .text:

9d00373c <_nmi_handler>:
9d00373c:	401a6000 	mfc0	k0,c0_status
9d003740:	3c1bffbf 	lui	k1,0xffbf
9d003744:	377bffff 	ori	k1,k1,0xffff
9d003748:	035bd024 	and	k0,k0,k1
9d00374c:	409a6000 	mtc0	k0,c0_status
9d003750:	42000018 	eret

Disassembly of section .dinit:

9d003754 <.dinit>:
9d003754:	00000000 	nop
9d003758:	22222222 	addi	v0,s1,8738
9d00375c:	22222222 	addi	v0,s1,8738
9d003760:	22222222 	addi	v0,s1,8738

Disassembly of section .text._on_reset:

9d003764 <_on_reset>:
9d003764:	03e00008 	jr	ra
9d003768:	00000000 	nop

Disassembly of section .text._on_bootstrap:

9d00376c <_on_bootstrap>:
9d00376c:	03e00008 	jr	ra
9d003770:	00000000 	nop
